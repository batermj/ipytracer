/// <reference types="backbone" />
import * as Backbone from 'backbone';
import { Kernel } from '@jupyterlab/services';
import { ManagerBase } from 'jupyter-js-widgets';
import { JSONObject } from 'phosphor/lib/algorithm/json';
import { IDisposable } from 'phosphor/lib/core/disposable';
import { Token } from 'phosphor/lib/core/token';
import { Widget } from 'phosphor/lib/ui/widget';
import { NotebookPanel } from 'jupyterlab/lib/notebook/notebook/panel';
import { INotebookModel } from 'jupyterlab/lib/notebook/notebook/model';
import { IRenderMime, RenderMime } from 'jupyterlab/lib/rendermime';
import { DocumentRegistry } from 'jupyterlab/lib/docregistry';
/**
 * The token identifying the JupyterLab plugin.
 */
export declare const INBWidgetExtension: Token<DocumentRegistry.IWidgetExtension<NotebookPanel, INotebookModel>>;
/**
 * The type of the provided value of the plugin in JupyterLab.
 */
export declare type INBWidgetExtension = DocumentRegistry.IWidgetExtension<NotebookPanel, INotebookModel>;
export declare class BackboneViewWrapper extends Widget {
    /**
     * Construct a new `Backbone` wrapper widget.
     *
     * @param view - The `Backbone.View` instance being wrapped.
     */
    constructor(view: Backbone.View<any>);
    onAfterAttach(msg: any): void;
    dispose(): void;
    private _view;
}
/**
 * A widget manager that returns phosphor widgets.
 */
export declare class WidgetManager extends ManagerBase<Widget> implements IDisposable {
    constructor(context: DocumentRegistry.IContext<DocumentRegistry.IModel>, rendermime: IRenderMime);
    newKernel(kernel: Kernel.IKernel): void;
    /**
     * Return a phosphor widget representing the view
     */
    display_view(msg: any, view: Backbone.View<Backbone.Model>, options: any): Promise<Widget>;
    /**
     * Create a comm.
     */
    _create_comm(target_name: string, model_id: string, data?: any): Promise<any>;
    /**
     * Get the currently-registered comms.
     */
    _get_comm_info(): Promise<any>;
    /**
     * Get whether the manager is disposed.
     *
     * #### Notes
     * This is a read-only property.
     */
    readonly isDisposed: boolean;
    /**
     * Dispose the resources held by the manager.
     */
    dispose(): void;
    /**
     * Load a class and return a promise to the loaded object.
     */
    protected loadClass(className: string, moduleName: string, moduleVersion: string, error: any): any;
    readonly context: DocumentRegistry.IContext<DocumentRegistry.IModel>;
    readonly rendermime: IRenderMime;
    readonly displayWithOutput: boolean;
    register(data: WidgetManager.IWidgetData): void;
    private _context;
    private _registry;
    private _rendermime;
    _commRegistration: IDisposable;
}
export declare namespace WidgetManager {
    interface IWidgetData {
        name: string;
        version: string;
        exports: any;
    }
}
/**
 * A renderer for widgets.
 */
export declare class WidgetRenderer implements RenderMime.IRenderer, IDisposable {
    constructor(widgetManager: WidgetManager);
    /**
     * Whether the input can safely sanitized for a given mimetype.
     */
    isSanitizable(mimetype: string): boolean;
    /**
     * Whether the input is safe without sanitization.
     */
    isSafe(mimetype: string): boolean;
    /**
     * Render a widget mimetype.
     */
    render(options: RenderMime.IRendererOptions<string | JSONObject>): Widget;
    /**
     * Get whether the manager is disposed.
     *
     * #### Notes
     * This is a read-only property.
     */
    readonly isDisposed: boolean;
    /**
     * Dispose the resources held by the manager.
     */
    dispose(): void;
    mimetypes: string[];
    private _manager;
}
