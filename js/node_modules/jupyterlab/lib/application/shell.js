// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var searching_1 = require('phosphor/lib/algorithm/searching');
var vector_1 = require('phosphor/lib/collections/vector');
var signaling_1 = require('phosphor/lib/core/signaling');
var boxpanel_1 = require('phosphor/lib/ui/boxpanel');
var dockpanel_1 = require('phosphor/lib/ui/dockpanel');
var panel_1 = require('phosphor/lib/ui/panel');
var splitpanel_1 = require('phosphor/lib/ui/splitpanel');
var stackedpanel_1 = require('phosphor/lib/ui/stackedpanel');
var tabbar_1 = require('phosphor/lib/ui/tabbar');
var widget_1 = require('phosphor/lib/ui/widget');
/**
 * The class name added to AppShell instances.
 */
var APPLICATION_SHELL_CLASS = 'jp-ApplicationShell';
/**
 * The class name added to side bar instances.
 */
var SIDEBAR_CLASS = 'jp-SideBar';
/**
 * The class name added to the current widget's title.
 */
var CURRENT_CLASS = 'jp-mod-current';
/**
 * The application shell for JupyterLab.
 */
var ApplicationShell = (function (_super) {
    __extends(ApplicationShell, _super);
    /**
     * Construct a new application shell.
     */
    function ApplicationShell() {
        var _this = this;
        _super.call(this);
        this.addClass(APPLICATION_SHELL_CLASS);
        this.id = 'main';
        var topPanel = this._topPanel = new panel_1.Panel();
        var hboxPanel = this._hboxPanel = new boxpanel_1.BoxPanel();
        var dockPanel = this._dockPanel = new dockpanel_1.DockPanel();
        var hsplitPanel = this._hsplitPanel = new splitpanel_1.SplitPanel();
        var leftHandler = this._leftHandler = new SideBarHandler('left');
        var rightHandler = this._rightHandler = new SideBarHandler('right');
        var rootLayout = new boxpanel_1.BoxLayout();
        topPanel.id = 'jp-top-panel';
        hboxPanel.id = 'jp-main-content-panel';
        dockPanel.id = 'jp-main-dock-panel';
        hsplitPanel.id = 'jp-main-split-panel';
        leftHandler.sideBar.addClass(SIDEBAR_CLASS);
        leftHandler.sideBar.addClass('jp-mod-left');
        leftHandler.stackedPanel.id = 'jp-left-stack';
        rightHandler.sideBar.addClass(SIDEBAR_CLASS);
        rightHandler.sideBar.addClass('jp-mod-right');
        rightHandler.stackedPanel.id = 'jp-right-stack';
        hboxPanel.spacing = 0;
        dockPanel.spacing = 5;
        hsplitPanel.spacing = 1;
        hboxPanel.direction = 'left-to-right';
        hsplitPanel.orientation = 'horizontal';
        splitpanel_1.SplitPanel.setStretch(leftHandler.stackedPanel, 0);
        splitpanel_1.SplitPanel.setStretch(dockPanel, 1);
        splitpanel_1.SplitPanel.setStretch(rightHandler.stackedPanel, 0);
        boxpanel_1.BoxPanel.setStretch(leftHandler.sideBar, 0);
        boxpanel_1.BoxPanel.setStretch(hsplitPanel, 1);
        boxpanel_1.BoxPanel.setStretch(rightHandler.sideBar, 0);
        hsplitPanel.addWidget(leftHandler.stackedPanel);
        hsplitPanel.addWidget(dockPanel);
        hsplitPanel.addWidget(rightHandler.stackedPanel);
        hboxPanel.addWidget(leftHandler.sideBar);
        hboxPanel.addWidget(hsplitPanel);
        hboxPanel.addWidget(rightHandler.sideBar);
        rootLayout.direction = 'top-to-bottom';
        rootLayout.spacing = 0; // TODO make this configurable?
        boxpanel_1.BoxLayout.setStretch(topPanel, 0);
        boxpanel_1.BoxLayout.setStretch(hboxPanel, 1);
        rootLayout.addWidget(topPanel);
        rootLayout.addWidget(hboxPanel);
        this.layout = rootLayout;
        this._dockPanel.currentChanged.connect(function (sender, args) {
            if (args.newValue) {
                args.newValue.title.className += " " + CURRENT_CLASS;
            }
            if (args.oldValue) {
                var title = args.oldValue.title;
                title.className = title.className.replace(CURRENT_CLASS, '');
            }
            _this.currentChanged.emit(args);
        });
    }
    Object.defineProperty(ApplicationShell.prototype, "currentWidget", {
        /**
         * The current widget in the shell's main area.
         *
         * #### Notes
         * This property is read-only.
         */
        get: function () {
            return this._dockPanel.currentWidget;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add a widget to the top content area.
     *
     * #### Notes
     * Widgets must have a unique `id` property, which will be used as the DOM id.
     */
    ApplicationShell.prototype.addToTopArea = function (widget, options) {
        if (options === void 0) { options = {}; }
        if (!widget.id) {
            console.error('widgets added to app shell must have unique id property');
            return;
        }
        // Temporary: widgets are added to the panel in order of insertion.
        this._topPanel.addWidget(widget);
    };
    /**
     * Add a widget to the left content area.
     *
     * #### Notes
     * Widgets must have a unique `id` property, which will be used as the DOM id.
     */
    ApplicationShell.prototype.addToLeftArea = function (widget, options) {
        if (options === void 0) { options = {}; }
        if (!widget.id) {
            console.error('widgets added to app shell must have unique id property');
            return;
        }
        var rank = 'rank' in options ? options.rank : 100;
        this._leftHandler.addWidget(widget, rank);
    };
    /**
     * Add a widget to the right content area.
     *
     * #### Notes
     * Widgets must have a unique `id` property, which will be used as the DOM id.
     */
    ApplicationShell.prototype.addToRightArea = function (widget, options) {
        if (options === void 0) { options = {}; }
        if (!widget.id) {
            console.error('widgets added to app shell must have unique id property');
            return;
        }
        var rank = 'rank' in options ? options.rank : 100;
        this._rightHandler.addWidget(widget, rank);
    };
    /**
     * Add a widget to the main content area.
     *
     * #### Notes
     * Widgets must have a unique `id` property, which will be used as the DOM id.
     */
    ApplicationShell.prototype.addToMainArea = function (widget) {
        if (!widget.id) {
            console.error('widgets added to app shell must have unique id property');
            return;
        }
        this._dockPanel.addWidget(widget, { mode: 'tab-after' });
    };
    /**
     * Activate a widget in the left area.
     */
    ApplicationShell.prototype.activateLeft = function (id) {
        this._leftHandler.activate(id);
    };
    /**
     * Activate a widget in the right area.
     */
    ApplicationShell.prototype.activateRight = function (id) {
        this._rightHandler.activate(id);
    };
    /**
     * Activate a widget in the main area.
     */
    ApplicationShell.prototype.activateMain = function (id) {
        var dock = this._dockPanel;
        var widget = searching_1.find(dock.widgets(), function (value) { return value.id === id; });
        if (widget) {
            dock.activateWidget(widget);
        }
    };
    /**
     * Collapse the left area.
     */
    ApplicationShell.prototype.collapseLeft = function () {
        this._leftHandler.collapse();
    };
    /**
     * Collapse the right area.
     */
    ApplicationShell.prototype.collapseRight = function () {
        this._rightHandler.collapse();
    };
    /**
     * Close all tracked widgets.
     */
    ApplicationShell.prototype.closeAll = function () {
        iteration_1.each(iteration_1.toArray(this._dockPanel.widgets()), function (widget) { widget.close(); });
    };
    return ApplicationShell;
}(widget_1.Widget));
exports.ApplicationShell = ApplicationShell;
// Define the signals for the `ApplicationShell` class.
signaling_1.defineSignal(ApplicationShell.prototype, 'currentChanged');
/**
 * A class which manages a side bar and related stacked panel.
 */
var SideBarHandler = (function () {
    /**
     * Construct a new side bar handler.
     */
    function SideBarHandler(side) {
        this._items = new vector_1.Vector();
        this._side = side;
        this._sideBar = new tabbar_1.TabBar({
            insertBehavior: 'none',
            removeBehavior: 'none',
            allowDeselect: true
        });
        this._stackedPanel = new stackedpanel_1.StackedPanel();
        this._sideBar.hide();
        this._stackedPanel.hide();
        this._sideBar.currentChanged.connect(this._onCurrentChanged, this);
        this._stackedPanel.widgetRemoved.connect(this._onWidgetRemoved, this);
    }
    Object.defineProperty(SideBarHandler.prototype, "sideBar", {
        /**
         * Get the tab bar managed by the handler.
         */
        get: function () {
            return this._sideBar;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SideBarHandler.prototype, "stackedPanel", {
        /**
         * Get the stacked panel managed by the handler
         */
        get: function () {
            return this._stackedPanel;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Activate a widget residing in the side bar by ID.
     *
     * @param id - The widget's unique ID.
     */
    SideBarHandler.prototype.activate = function (id) {
        var widget = this._findWidgetByID(id);
        if (widget) {
            this._sideBar.currentTitle = widget.title;
            widget.activate();
        }
    };
    /**
     * Collapse the sidebar so no items are expanded.
     */
    SideBarHandler.prototype.collapse = function () {
        this._sideBar.currentTitle = null;
    };
    /**
     * Add a widget and its title to the stacked panel and side bar.
     *
     * If the widget is already added, it will be moved.
     */
    SideBarHandler.prototype.addWidget = function (widget, rank) {
        widget.parent = null;
        widget.hide();
        var item = { widget: widget, rank: rank };
        var index = this._findInsertIndex(item);
        this._items.insert(index, item);
        this._stackedPanel.insertWidget(index, widget);
        this._sideBar.insertTab(index, widget.title);
        this._refreshVisibility();
    };
    /**
     * Find the insertion index for a rank item.
     */
    SideBarHandler.prototype._findInsertIndex = function (item) {
        return searching_1.upperBound(this._items, item, Private.itemCmp);
    };
    /**
     * Find the index of the item with the given widget, or `-1`.
     */
    SideBarHandler.prototype._findWidgetIndex = function (widget) {
        return searching_1.findIndex(this._items, function (item) { return item.widget === widget; });
    };
    /**
     * Find the widget which owns the given title, or `null`.
     */
    SideBarHandler.prototype._findWidgetByTitle = function (title) {
        var item = searching_1.find(this._items, function (value) { return value.widget.title === title; });
        return item ? item.widget : null;
    };
    /**
     * Find the widget with the given id, or `null`.
     */
    SideBarHandler.prototype._findWidgetByID = function (id) {
        var item = searching_1.find(this._items, function (value) { return value.widget.id === id; });
        return item ? item.widget : null;
    };
    /**
     * Refresh the visibility of the side bar and stacked panel.
     */
    SideBarHandler.prototype._refreshVisibility = function () {
        this._sideBar.setHidden(this._sideBar.titles.length === 0);
        this._stackedPanel.setHidden(this._sideBar.currentTitle === null);
    };
    /**
     * Handle the `currentChanged` signal from the sidebar.
     */
    SideBarHandler.prototype._onCurrentChanged = function (sender, args) {
        var oldWidget = this._findWidgetByTitle(args.previousTitle);
        var newWidget = this._findWidgetByTitle(args.currentTitle);
        if (oldWidget) {
            oldWidget.hide();
        }
        if (newWidget) {
            newWidget.show();
        }
        if (newWidget) {
            document.body.setAttribute("data-" + this._side + "Area", newWidget.id);
        }
        else {
            document.body.removeAttribute("data-" + this._side + "Area");
        }
        this._refreshVisibility();
    };
    /*
     * Handle the `widgetRemoved` signal from the stacked panel.
     */
    SideBarHandler.prototype._onWidgetRemoved = function (sender, widget) {
        this._items.removeAt(this._findWidgetIndex(widget));
        this._sideBar.removeTab(widget.title);
        this._refreshVisibility();
    };
    return SideBarHandler;
}());
var Private;
(function (Private) {
    /**
     * A less-than comparison function for side bar rank items.
     */
    function itemCmp(first, second) {
        return first.rank - second.rank;
    }
    Private.itemCmp = itemCmp;
})(Private || (Private = {}));
//# sourceMappingURL=shell.js.map