// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var CodeMirror = require('codemirror');
require('codemirror/mode/meta');
var token_1 = require('phosphor/lib/core/token');
var codemirror_1 = require('../codemirror');
var widget_1 = require('../codemirror/widget');
var docregistry_1 = require('../docregistry');
/**
 * The class name added to a dirty widget.
 */
var DIRTY_CLASS = 'jp-mod-dirty';
/**
 * The class name added to a jupyter code mirror widget.
 */
var EDITOR_CLASS = 'jp-EditorWidget';
/* tslint:disable */
/**
 * The editor tracker token.
 */
exports.IEditorTracker = new token_1.Token('jupyter.services.editor-tracker');
/* tslint:enable */
/**
 * A document widget for codemirrors.
 */
var EditorWidget = (function (_super) {
    __extends(EditorWidget, _super);
    /**
     * Construct a new editor widget.
     */
    function EditorWidget(context) {
        var _this = this;
        _super.call(this, {
            extraKeys: {
                'Tab': 'indentMore',
                'Shift-Enter': function () { }
            },
            indentUnit: 4,
            theme: widget_1.DEFAULT_CODEMIRROR_THEME,
            lineNumbers: true,
            lineWrapping: true,
        });
        this.addClass(EDITOR_CLASS);
        this._context = context;
        var editor = this.editor;
        var model = context.model;
        var doc = editor.getDoc();
        doc.setValue(model.toString());
        this.title.label = context.path.split('/').pop();
        codemirror_1.loadModeByFileName(editor, context.path);
        model.stateChanged.connect(function (m, args) {
            if (args.name === 'dirty') {
                if (args.newValue) {
                    _this.title.className += " " + DIRTY_CLASS;
                }
                else {
                    _this.title.className = _this.title.className.replace(DIRTY_CLASS, '');
                }
            }
        });
        context.pathChanged.connect(function (c, path) {
            codemirror_1.loadModeByFileName(editor, path);
            _this.title.label = path.split('/').pop();
        });
        model.contentChanged.connect(function () {
            var old = doc.getValue();
            var text = model.toString();
            if (old !== text) {
                doc.setValue(text);
            }
        });
        CodeMirror.on(doc, 'change', function (instance, change) {
            if (change.origin !== 'setValue') {
                model.fromString(instance.getValue());
            }
        });
    }
    Object.defineProperty(EditorWidget.prototype, "context", {
        /**
         * Get the context for the editor widget.
         */
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    return EditorWidget;
}(widget_1.CodeMirrorWidget));
exports.EditorWidget = EditorWidget;
/**
 * A widget factory for editors.
 */
var EditorWidgetFactory = (function (_super) {
    __extends(EditorWidgetFactory, _super);
    function EditorWidgetFactory() {
        _super.apply(this, arguments);
    }
    /**
     * Create a new widget given a context.
     */
    EditorWidgetFactory.prototype.createNewWidget = function (context) {
        return new EditorWidget(context);
    };
    return EditorWidgetFactory;
}(docregistry_1.ABCWidgetFactory));
exports.EditorWidgetFactory = EditorWidgetFactory;
//# sourceMappingURL=widget.js.map