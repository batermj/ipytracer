// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var panel_1 = require('phosphor/lib/ui/panel');
var widget_1 = require('phosphor/lib/ui/widget');
/**
 * The class name added to dialog instances.
 */
var DIALOG_CLASS = 'jp-Dialog';
/**
 * The class name added to dialog content node.
 */
var CONTENT_CLASS = 'jp-Dialog-content';
/**
 * The class name added to dialog header node.
 */
var HEADER_CLASS = 'jp-Dialog-header';
/**
 * The class name added to dialog title node.
 */
var TITLE_CLASS = 'jp-Dialog-title';
/**
 * The class name added to dialog body node.
 */
var BODY_CLASS = 'jp-Dialog-body';
/**
 * The class name added to a dialog body content node.
 */
var BODY_CONTENT_CLASS = 'jp-Dialog-bodyContent';
/**
 * The class name added to a dialog content node.
 */
var FOOTER_CLASS = 'jp-Dialog-footer';
/**
 * The class name added to a dialog button node.
 */
var BUTTON_CLASS = 'jp-Dialog-button';
/**
 * The class name added to a dialog button icon node.
 */
var BUTTON_ICON_CLASS = 'jp-Dialog-buttonIcon';
/**
 * The class name added to a dialog button text node.
 */
var BUTTON_TEXT_CLASS = 'jp-Dialog-buttonText';
/*
 * The class name added to dialog Confirm buttons.
 */
var OK_BUTTON_CLASS = 'jp-Dialog-okButton';
/**
 * The class name added to dialog Cancel buttons.
 */
var CANCEL_BUTTON_CLASS = 'jp-Dialog-cancelButton';
/**
/*
* The class name added to dialog Warning buttons.
*/
var WARNING_BUTTON_CLASS = 'jp-Dialog-warningButton';
/**
 * The class name added to dialog input field wrappers.
 */
var INPUT_WRAPPER_CLASS = 'jp-Dialog-inputWrapper';
/**
 * The class name added to dialog input fields.
 */
var INPUT_CLASS = 'jp-Dialog-input';
/**
 * The class name added to dialog select wrappers.
 */
var SELECT_WRAPPER_CLASS = 'jp-Dialog-selectWrapper';
/**
 * The class name added to dialog select nodes.
 */
var SELECT_CLASS = 'jp-Dialog-select';
/**
 * A default confirmation button.
 */
exports.okButton = {
    text: 'OK',
    className: OK_BUTTON_CLASS
};
/**
 * A default cancel button.
 */
exports.cancelButton = {
    text: 'CANCEL',
    className: CANCEL_BUTTON_CLASS
};
/**
* A default delete button.
*/
exports.deleteButton = {
    text: 'DELETE',
    className: WARNING_BUTTON_CLASS
};
exports.warnButton = {
    text: 'OK',
    className: WARNING_BUTTON_CLASS
};
/**
 * Create a dialog and show it.
 *
 * @param options - The dialog setup options.
 *
 * @returns A promise that resolves to the button item that was selected.
 */
function showDialog(options) {
    options = options || {};
    var host = options.host || document.body;
    options.host = host;
    options.body = options.body || '';
    // NOTE: This code assumes only one dialog is shown at the time:
    exports.okButton.text = options.okText ? options.okText : 'OK';
    options.buttons = options.buttons || [exports.cancelButton, exports.okButton];
    if (!(options.body instanceof widget_1.Widget)) {
        options.body = createDialogBody(options.body);
    }
    return new Promise(function (resolve, reject) {
        var dialog = new Dialog(options, resolve, reject);
        widget_1.Widget.attach(dialog, host);
    });
}
exports.showDialog = showDialog;
/**
 * A dialog panel.
 */
var Dialog = (function (_super) {
    __extends(Dialog, _super);
    /**
     * Create a dialog panel instance.
     *
     * @param options - The dialog setup options.
     *
     * @param resolve - The function that resolves the dialog promise.
     *
     * @param reject - The function that rejects the dialog promise.
     *
     * #### Notes
     * Currently the dialog resolves with `cancelButton` rather than
     * rejecting the dialog promise.
     */
    function Dialog(options, resolve, reject) {
        _super.call(this);
        if (!(options.body instanceof widget_1.Widget)) {
            throw 'A widget dialog can only be created with a widget as its body.';
        }
        this.resolve = resolve;
        this.reject = reject;
        // Create the dialog nodes (except for the buttons).
        var content = new panel_1.Panel();
        var header = new widget_1.Widget({ node: document.createElement('div') });
        var body = new panel_1.Panel();
        var footer = new widget_1.Widget({ node: document.createElement('div') });
        var title = document.createElement('span');
        this.addClass(DIALOG_CLASS);
        if (options.dialogClass) {
            this.addClass(options.dialogClass);
        }
        content.addClass(CONTENT_CLASS);
        header.addClass(HEADER_CLASS);
        body.addClass(BODY_CLASS);
        footer.addClass(FOOTER_CLASS);
        title.className = TITLE_CLASS;
        this.addWidget(content);
        content.addWidget(header);
        content.addWidget(body);
        content.addWidget(footer);
        header.node.appendChild(title);
        // Populate the nodes.
        title.textContent = options.title || '';
        var child = options.body;
        child.addClass(BODY_CONTENT_CLASS);
        body.addWidget(child);
        this._buttons = options.buttons;
        this._buttonNodes = options.buttons.map(createButton);
        this._buttonNodes.map(function (buttonNode) {
            footer.node.appendChild(buttonNode);
        });
    }
    /**
     * Handle the DOM events for the directory listing.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the panel's DOM node. It should
     * not be called directly by user code.
     */
    Dialog.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'keydown':
                this.evtKeydown(event);
                break;
            case 'contextmenu':
                this.evtContextMenu(event);
                break;
            default:
                break;
        }
    };
    /**
     * Handle an `'after-attach'` message to the widget.
     *
     * @param msg - The `'after-attach'` message
     */
    Dialog.prototype.onAfterAttach = function (msg) {
        var _this = this;
        var node = this.node;
        node.addEventListener('keydown', this, true);
        node.addEventListener('contextmenu', this, true);
        node.addEventListener('click', this);
        this._buttonNodes.map(function (buttonNode) {
            buttonNode.addEventListener('click', _this.evtButtonClick.bind(_this));
        });
        // Focus the ok button if given.
        var index = this._buttons.indexOf(exports.okButton);
        if (index !== -1) {
            this._buttonNodes[index].focus();
        }
    };
    /**
     * Handle the `'click'` event for a dialog button.
     *
     * @param event - The DOM event sent to the widget
     */
    Dialog.prototype.evtButtonClick = function (event) {
        for (var _i = 0, _a = this._buttonNodes; _i < _a.length; _i++) {
            var buttonNode = _a[_i];
            if (buttonNode.contains(event.target)) {
                this.close();
                var button = this._buttons[this._buttonNodes.indexOf(buttonNode)];
                this.resolve(button);
            }
        }
    };
    /**
     * Handle the `'keydown'` event for the widget.
     *
     * @param event - The DOM event sent to the widget
     */
    Dialog.prototype.evtKeydown = function (event) {
        // Check for escape key
        if (event.keyCode === 27) {
            this.close();
            this.resolve(exports.cancelButton);
        }
    };
    /**
     * Handle the `'contextmenu'` event for the widget.
     *
     * @param event - The DOM event sent to the widget
     */
    Dialog.prototype.evtContextMenu = function (event) {
        event.preventDefault();
        event.stopPropagation();
    };
    return Dialog;
}(panel_1.Panel));
/**
 * Create a dialog body widget from a non-widget input.
 */
function createDialogBody(body) {
    var child;
    if (typeof body === 'string') {
        child = document.createElement('span');
        child.innerHTML = body;
    }
    else if (body) {
        child = body;
        switch (child.tagName) {
            case 'INPUT':
                child = wrapInput(child);
                break;
            case 'SELECT':
                child = wrapSelect(child);
                break;
            default:
                child = styleElements(child);
                break;
        }
    }
    child.classList.add(BODY_CONTENT_CLASS);
    return new widget_1.Widget({ node: child });
}
/**
 * Style the child elements of a parent element.
 */
function styleElements(element) {
    for (var i = 0; i < element.children.length; i++) {
        var child = element.children[i];
        var next = child.nextSibling;
        switch (child.tagName) {
            case 'INPUT':
                child = wrapInput(child);
                element.insertBefore(child, next);
                break;
            case 'SELECT':
                child = wrapSelect(child);
                element.insertBefore(child, next);
                break;
            default:
                break;
        }
    }
    return element;
}
/**
 * Create a node for a button item.
 */
function createButton(item) {
    var button = document.createElement('button');
    button.className = BUTTON_CLASS;
    button.tabIndex = -1;
    if (item.className) {
        button.classList.add(item.className);
    }
    var icon = document.createElement('span');
    icon.className = BUTTON_ICON_CLASS;
    if (item.icon) {
        icon.classList.add(item.icon);
    }
    var text = document.createElement('span');
    text.className = BUTTON_TEXT_CLASS;
    text.textContent = item.text;
    button.appendChild(icon);
    button.appendChild(text);
    return button;
}
/**
 * Wrap and style an input node.
 */
function wrapInput(input) {
    var wrapper = document.createElement('div');
    wrapper.className = INPUT_WRAPPER_CLASS;
    wrapper.appendChild(input);
    input.classList.add(INPUT_CLASS);
    return wrapper;
}
/**
 * Wrap and style a select node.
 */
function wrapSelect(select) {
    var wrapper = document.createElement('div');
    wrapper.className = SELECT_WRAPPER_CLASS;
    wrapper.appendChild(select);
    select.classList.add(SELECT_CLASS);
    return wrapper;
}
//# sourceMappingURL=index.js.map