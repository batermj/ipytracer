// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var dsv = require('d3-dsv');
var signaling_1 = require('phosphor/lib/core/signaling');
var vdom_1 = require('phosphor/lib/ui/vdom');
var vdom_2 = require('../common/vdom');
var widget_1 = require('../renderers/widget');
/**
 * The hard limit on the number of rows to display.
 */
exports.DISPLAY_LIMIT = 1000;
/**
 * The class name added to a csv table widget.
 */
var CSV_TABLE_CLASS = 'jp-CSVTable';
/**
 * A CSV table content model.
 */
var CSVModel = (function (_super) {
    __extends(CSVModel, _super);
    /**
     * Instantiate a CSV model.
     */
    function CSVModel(options) {
        if (options === void 0) { options = {}; }
        _super.call(this);
        this._content = options.content || '';
        this._delimiter = options.delimiter || ',';
    }
    Object.defineProperty(CSVModel.prototype, "content", {
        /**
         * The raw model content.
         */
        get: function () {
            return this._content;
        },
        set: function (content) {
            if (this._content === content) {
                return;
            }
            this._content = content;
            this.stateChanged.emit(void 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CSVModel.prototype, "delimiter", {
        /**
         * The CSV delimiter value.
         */
        get: function () {
            return this._delimiter;
        },
        set: function (delimiter) {
            if (this._delimiter === delimiter) {
                return;
            }
            this._delimiter = delimiter;
            this.stateChanged.emit(void 0);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose this model.
     */
    CSVModel.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        _super.prototype.dispose.call(this);
        signaling_1.clearSignalData(this);
    };
    /**
     * Parse the content using the model's delimiter.
     *
     * #### Notes
     * This method will always return parsed content that has at most the display
     * limit worth of rows, currently maxing out at 1000 rows.
     */
    CSVModel.prototype.parse = function () {
        var output = dsv.dsvFormat(this._delimiter).parse(this._content);
        var available = output.length;
        var maximum = exports.DISPLAY_LIMIT;
        if (available > maximum) {
            // Mutate the array instead of slicing in order to conserve memory.
            output.splice(maximum);
            this.maxExceeded.emit({ available: available, maximum: maximum });
        }
        return output;
    };
    return CSVModel;
}(vdom_2.VDomModel));
exports.CSVModel = CSVModel;
// Define the signals for the `CSVModel` class.
signaling_1.defineSignal(CSVModel.prototype, 'maxExceeded');
/**
 * A CSV table content widget.
 */
var CSVTable = (function (_super) {
    __extends(CSVTable, _super);
    /**
     * Instantiate a new CSV table widget.
     */
    function CSVTable() {
        _super.call(this);
        this.addClass(CSV_TABLE_CLASS);
        this.addClass(widget_1.HTML_COMMON_CLASS);
    }
    /**
     * Render the content as virtual DOM nodes.
     */
    CSVTable.prototype.render = function () {
        if (!this.model) {
            return vdom_1.h.table([vdom_1.h.thead(), vdom_1.h.tbody()]);
        }
        var rows = this.model.parse();
        var cols = rows.columns || [];
        return vdom_1.h.table([
            vdom_1.h.thead(cols.map(function (col) { return vdom_1.h.th(col); })),
            vdom_1.h.tbody(rows.map(function (row) { return vdom_1.h.tr(cols.map(function (col) { return vdom_1.h.td(row[col]); })); }))
        ]);
    };
    return CSVTable;
}(vdom_2.VDomWidget));
exports.CSVTable = CSVTable;
//# sourceMappingURL=table.js.map