// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var docregistry_1 = require('../docregistry');
var statedb_1 = require('../statedb');
var widget_1 = require('./widget');
/**
 * The state database namespace for CSV widgets.
 */
var NAMESPACE = 'csvwidgets';
/**
 * The table file handler extension.
 */
exports.csvHandlerExtension = {
    id: 'jupyter.extensions.csvHandler',
    requires: [docregistry_1.IDocumentRegistry, statedb_1.IStateDB],
    activate: activateCSVWidget,
    autoStart: true
};
/**
 * Activate the table widget extension.
 */
function activateCSVWidget(app, registry, state) {
    var factory = new widget_1.CSVWidgetFactory({
        name: 'Table',
        fileExtensions: ['.csv'],
        defaultFor: ['.csv']
    });
    registry.addWidgetFactory(factory);
    factory.widgetCreated.connect(function (sender, widget) {
        // Add the CSV path to the state database.
        var key = NAMESPACE + ":" + widget.context.path;
        state.save(key, { path: widget.context.path });
        // Remove the CSV path from the state database on disposal.
        widget.disposed.connect(function () { state.remove(key); });
        // Keep track of path changes in the state database.
        widget.context.pathChanged.connect(function (sender, path) {
            state.remove(key);
            key = NAMESPACE + ":" + path;
            state.save(key, { path: path });
        });
    });
    // Reload any CSV widgets whose state has been stored.
    Promise.all([state.fetchNamespace(NAMESPACE), app.started])
        .then(function (_a) {
        var items = _a[0];
        var open = 'file-operations:open';
        items.forEach(function (item) { app.commands.execute(open, item.value); });
    });
}
//# sourceMappingURL=plugin.js.map