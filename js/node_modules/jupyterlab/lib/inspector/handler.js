// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var signaling_1 = require('phosphor/lib/core/signaling');
/**
 * An object that handles code inspection.
 */
var InspectionHandler = (function () {
    /**
     * Construct a new inspection handler for a widget.
     */
    function InspectionHandler(options) {
        this._activeCell = null;
        this._isDisposed = false;
        this._kernel = null;
        this._pending = 0;
        this._rendermime = null;
        this._kernel = options.kernel || null;
        this._rendermime = options.rendermime;
    }
    Object.defineProperty(InspectionHandler.prototype, "activeCell", {
        /**
         * The cell widget used by the inspection handler.
         */
        get: function () {
            return this._activeCell;
        },
        set: function (newValue) {
            if (newValue === this._activeCell) {
                return;
            }
            if (this._activeCell && !this._activeCell.isDisposed) {
                var editor = this._activeCell.editor;
                editor.textChanged.disconnect(this.onTextChanged, this);
            }
            this._activeCell = newValue;
            if (this._activeCell) {
                // Clear ephemeral inspectors in preparation for a new editor.
                this.ephemeralCleared.emit(void 0);
                var editor = this._activeCell.editor;
                editor.textChanged.connect(this.onTextChanged, this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InspectionHandler.prototype, "kernel", {
        /**
         * The kernel used by the inspection handler.
         */
        get: function () {
            return this._kernel;
        },
        set: function (value) {
            this._kernel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InspectionHandler.prototype, "isDisposed", {
        /**
         * Get whether the inspection handler is disposed.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources used by the handler.
     */
    InspectionHandler.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        this._activeCell = null;
        this.disposed.emit(void 0);
        signaling_1.clearSignalData(this);
    };
    /**
     * Handle a text changed signal from an editor.
     *
     * #### Notes
     * Update the hints inspector based on a text change.
     */
    InspectionHandler.prototype.onTextChanged = function (editor, change) {
        var _this = this;
        var update = {
            content: null,
            type: 'hints'
        };
        // Clear hints if the new text value is empty or kernel is unavailable.
        if (!change.newValue || !this._kernel) {
            this.inspected.emit(update);
            return;
        }
        var contents = {
            code: change.newValue,
            cursor_pos: change.position,
            detail_level: 0
        };
        var pending = ++this._pending;
        this._kernel.requestInspect(contents).then(function (msg) {
            var value = msg.content;
            // If handler has been disposed, bail.
            if (_this.isDisposed) {
                _this.inspected.emit(update);
                return;
            }
            // If a newer text change has created a pending request, bail.
            if (pending !== _this._pending) {
                _this.inspected.emit(update);
                return;
            }
            // Hint request failures or negative results fail silently.
            if (value.status !== 'ok' || !value.found) {
                _this.inspected.emit(update);
                return;
            }
            var bundle = value.data;
            var trusted = true;
            var widget = _this._rendermime.render({ bundle: bundle, trusted: trusted });
            update.content = widget;
            _this.inspected.emit(update);
        });
    };
    return InspectionHandler;
}());
exports.InspectionHandler = InspectionHandler;
// Define the signals for the `FileBrowserModel` class.
signaling_1.defineSignal(InspectionHandler.prototype, 'ephemeralCleared');
signaling_1.defineSignal(InspectionHandler.prototype, 'disposed');
signaling_1.defineSignal(InspectionHandler.prototype, 'inspected');
//# sourceMappingURL=handler.js.map