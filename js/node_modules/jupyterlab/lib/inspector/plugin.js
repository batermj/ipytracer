// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var commandpalette_1 = require('../commandpalette');
var _1 = require('./');
/**
 * A service providing an inspector panel.
 */
exports.inspectorProvider = {
    id: 'jupyter.services.inspector',
    requires: [commandpalette_1.ICommandPalette],
    provides: _1.IInspector,
    activate: activateInspector
};
/**
 * A class that manages inspector widget instances and offers persistent
 * `IInspector` instance that other plugins can communicate with.
 */
var InspectorManager = (function () {
    function InspectorManager() {
        this._inspector = null;
        this._source = null;
    }
    Object.defineProperty(InspectorManager.prototype, "inspector", {
        /**
         * The current inspector widget.
         */
        get: function () {
            return this._inspector;
        },
        set: function (inspector) {
            if (this._inspector === inspector) {
                return;
            }
            this._inspector = inspector;
            // If an inspector was added and it has no source
            if (inspector && !inspector.source) {
                inspector.source = this._source;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InspectorManager.prototype, "source", {
        /**
         * The source of events the inspector panel listens for.
         */
        get: function () {
            return this._source;
        },
        set: function (source) {
            if (this._source !== source) {
                if (this._source) {
                    this._source.disposed.disconnect(this._onSourceDisposed, this);
                }
                this._source = source;
                this._source.disposed.connect(this._onSourceDisposed, this);
            }
            if (this._inspector && !this._inspector.isDisposed) {
                this._inspector.source = this._source;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handle the source disposed signal.
     */
    InspectorManager.prototype._onSourceDisposed = function () {
        this._source = null;
    };
    return InspectorManager;
}());
/**
 * Activate the console extension.
 */
function activateInspector(app, palette) {
    var manager = new InspectorManager();
    var openInspectorCommand = 'inspector:open';
    function newInspector() {
        var inspector = new _1.Inspector({ items: Private.defaultInspectorItems });
        inspector.id = 'jp-inspector';
        inspector.title.label = 'Inspector';
        inspector.title.closable = true;
        inspector.disposed.connect(function () {
            if (manager.inspector === inspector) {
                manager.inspector = null;
            }
        });
        return inspector;
    }
    function openInspector() {
        if (!manager.inspector || manager.inspector.isDisposed) {
            manager.inspector = newInspector();
            app.shell.addToMainArea(manager.inspector);
        }
        if (manager.inspector.isAttached) {
            app.shell.activateMain(manager.inspector.id);
        }
    }
    app.commands.addCommand(openInspectorCommand, {
        execute: openInspector,
        label: 'Open Inspector'
    });
    palette.addItem({
        command: openInspectorCommand,
        category: 'Inspector'
    });
    return manager;
}
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * The default set of inspector items added to the inspector panel.
     */
    Private.defaultInspectorItems = [
        {
            className: 'jp-HintsInspectorItem',
            name: 'Hints',
            rank: 20,
            type: 'hints'
        }
    ];
})(Private || (Private = {}));
//# sourceMappingURL=plugin.js.map