// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var services_1 = require('@jupyterlab/services');
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var vector_1 = require('phosphor/lib/collections/vector');
var signaling_1 = require('phosphor/lib/core/signaling');
var utils_1 = require('./utils');
/**
 * The duration of auto-refresh in ms.
 */
var REFRESH_DURATION = 10000;
/**
 * The enforced time between refreshes in ms.
 */
var MIN_REFRESH = 1000;
/**
 * An implementation of a file browser model.
 *
 * #### Notes
 * All paths parameters without a leading `'/'` are interpreted as relative to
 * the current directory.  Supports `'../'` syntax.
 */
var FileBrowserModel = (function () {
    /**
     * Construct a new file browser model.
     */
    function FileBrowserModel(options) {
        var _this = this;
        this._maxUploadSizeMb = 15;
        this._manager = null;
        this._sessions = new vector_1.Vector();
        this._items = new vector_1.Vector();
        this._paths = new Set();
        this._pendingPath = null;
        this._pending = null;
        this._timeoutId = -1;
        this._refreshId = -1;
        this._blackoutId = -1;
        this._requested = false;
        this._manager = options.manager;
        this._model = { path: '', name: '/', type: 'directory' };
        this._manager.contents.fileChanged.connect(this._onFileChanged, this);
        this._manager.sessions.runningChanged.connect(this._onRunningChanged, this);
        this._scheduleUpdate();
        this._refreshId = setInterval(function () {
            _this._scheduleUpdate();
        }, REFRESH_DURATION);
    }
    Object.defineProperty(FileBrowserModel.prototype, "path", {
        /**
         * Get the current path.
         */
        get: function () {
            return this._model ? this._model.path : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "isDisposed", {
        /**
         * Get whether the model is disposed.
         */
        get: function () {
            return this._model === null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "specs", {
        /**
         * Get the kernel spec models.
         */
        get: function () {
            return this._manager.sessions.specs;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the model.
     */
    FileBrowserModel.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        clearTimeout(this._timeoutId);
        clearInterval(this._refreshId);
        clearTimeout(this._blackoutId);
        this._model = null;
        this._sessions.clear();
        this._items.clear();
        this._manager = null;
        signaling_1.clearSignalData(this);
    };
    /**
     * Create an iterator over the model's items.
     *
     * @returns A new iterator over the model's items.
     */
    FileBrowserModel.prototype.items = function () {
        return this._items.iter();
    };
    /**
     * Create an iterator over the active sessions in the directory.
     *
     * @returns A new iterator over the model's active sessions.
     */
    FileBrowserModel.prototype.sessions = function () {
        return this._sessions.iter();
    };
    /**
     * Change directory.
     *
     * @param path - The path to the file or directory.
     *
     * @returns A promise with the contents of the directory.
     */
    FileBrowserModel.prototype.cd = function (newValue) {
        var _this = this;
        if (newValue === void 0) { newValue = '.'; }
        if (newValue !== '.') {
            newValue = Private.normalizePath(this._model.path, newValue);
        }
        else {
            newValue = this._pendingPath || this._model.path;
        }
        // Collapse requests to the same directory.
        if (newValue === this._pendingPath) {
            return this._pending;
        }
        var oldValue = this.path;
        var options = { content: true };
        this._pendingPath = newValue;
        if (oldValue !== newValue) {
            this._sessions.clear();
        }
        var manager = this._manager;
        this._pending = manager.contents.get(newValue, options).then(function (contents) {
            _this._handleContents(contents);
            _this._pendingPath = null;
            if (oldValue !== newValue) {
                _this.pathChanged.emit({
                    name: 'path',
                    oldValue: oldValue,
                    newValue: newValue
                });
            }
            _this._onRunningChanged(manager.sessions, manager.sessions.running());
            _this.refreshed.emit(void 0);
        }).catch(function (error) {
            utils_1.showErrorMessage('Server Connection Error', error);
            _this._pendingPath = null;
        });
        return this._pending;
    };
    /**
     * Copy a file.
     *
     * @param fromFile - The path of the original file.
     *
     * @param toDir - The path to the target directory.
     *
     * @returns A promise which resolves to the contents of the file.
     */
    FileBrowserModel.prototype.copy = function (fromFile, toDir) {
        var normalizePath = Private.normalizePath;
        fromFile = normalizePath(this._model.path, fromFile);
        toDir = normalizePath(this._model.path, toDir);
        return this._manager.contents.copy(fromFile, toDir);
    };
    /**
     * Delete a file.
     *
     * @param: path - The path to the file to be deleted.
     *
     * @returns A promise which resolves when the file is deleted.
     */
    FileBrowserModel.prototype.deleteFile = function (path) {
        var normalizePath = Private.normalizePath;
        path = normalizePath(this._model.path, path);
        return this._manager.contents.delete(path);
    };
    /**
     * Download a file.
     *
     * @param - path - The path of the file to be downloaded.
     */
    FileBrowserModel.prototype.download = function (path) {
        var url = this._manager.contents.getDownloadUrl(path);
        var element = document.createElement('a');
        element.setAttribute('href', url);
        element.setAttribute('download', '');
        element.click();
    };
    /**
     * Create a new untitled file or directory in the current directory.
     *
     * @param type - The type of file object to create. One of
     *  `['file', 'notebook', 'directory']`.
     *
     * @param ext - Optional extension for `'file'` types (defaults to `'.txt'`).
     *
     * @returns A promise containing the new file contents model.
     */
    FileBrowserModel.prototype.newUntitled = function (options) {
        if (options.type === 'file') {
            options.ext = options.ext || '.txt';
        }
        options.path = options.path || this._model.path;
        return this._manager.contents.newUntitled(options);
    };
    /**
     * Rename a file or directory.
     *
     * @param path - The path to the original file.
     *
     * @param newPath - The path to the new file.
     *
     * @returns A promise containing the new file contents model.
     */
    FileBrowserModel.prototype.rename = function (path, newPath) {
        // Handle relative paths.
        path = Private.normalizePath(this._model.path, path);
        newPath = Private.normalizePath(this._model.path, newPath);
        return this._manager.contents.rename(path, newPath);
    };
    /**
     * Upload a `File` object.
     *
     * @param file - The `File` object to upload.
     *
     * @param overwrite - Whether to overwrite an existing file.
     *
     * @returns A promise containing the new file contents model.
     *
     * #### Notes
     * This will fail to upload files that are too big to be sent in one
     * request to the server.
     */
    FileBrowserModel.prototype.upload = function (file, overwrite) {
        var _this = this;
        // Skip large files with a warning.
        if (file.size > this._maxUploadSizeMb * 1024 * 1024) {
            var msg = "Cannot upload file (>" + this._maxUploadSizeMb + " MB) ";
            msg += "\"" + file.name + "\"";
            console.warn(msg);
            return Promise.reject(new Error(msg));
        }
        if (overwrite) {
            return this._upload(file);
        }
        var path = this._model.path;
        path = path ? path + '/' + file.name : file.name;
        return this._manager.contents.get(path, {}).then(function () {
            var msg = "\"" + file.name + "\" already exists";
            throw new Error(msg);
        }, function () {
            return _this._upload(file);
        });
    };
    /**
     * Shut down a session by session id.
     *
     * @param id - The id of the session.
     *
     * @returns A promise that resolves when the action is complete.
     */
    FileBrowserModel.prototype.shutdown = function (id) {
        return this._manager.sessions.shutdown(id);
    };
    /**
     * Perform the actual upload.
     */
    FileBrowserModel.prototype._upload = function (file) {
        var _this = this;
        // Gather the file model parameters.
        var path = this._model.path;
        path = path ? path + '/' + file.name : file.name;
        var name = file.name;
        var isNotebook = file.name.indexOf('.ipynb') !== -1;
        var type = isNotebook ? 'notebook' : 'file';
        var format = isNotebook ? 'json' : 'base64';
        // Get the file content.
        var reader = new FileReader();
        if (isNotebook) {
            reader.readAsText(file);
        }
        else {
            reader.readAsArrayBuffer(file);
        }
        return new Promise(function (resolve, reject) {
            reader.onload = function (event) {
                var model = {
                    type: type,
                    format: format,
                    name: name,
                    content: Private.getContent(reader)
                };
                _this._manager.contents.save(path, model).then(function (contents) {
                    resolve(contents);
                }).catch(reject);
            };
            reader.onerror = function (event) {
                reject(Error(("Failed to upload \"" + file.name + "\":") + event));
            };
        });
    };
    /**
     * Handle an updated contents model.
     */
    FileBrowserModel.prototype._handleContents = function (contents) {
        var _this = this;
        // Update our internal data.
        this._model = {
            name: contents.name,
            path: contents.path,
            type: contents.type,
            writable: contents.writable,
            created: contents.created,
            last_modified: contents.last_modified,
            mimetype: contents.mimetype,
            format: contents.format
        };
        this._items.clear();
        this._paths.clear();
        iteration_1.each(contents.content, function (model) {
            _this._paths.add(model.path);
        });
        this._items = new vector_1.Vector(contents.content);
    };
    /**
     * Handle a change to the running sessions.
     */
    FileBrowserModel.prototype._onRunningChanged = function (sender, models) {
        var _this = this;
        this._sessions.clear();
        iteration_1.each(models, function (model) {
            if (_this._paths.has(model.notebook.path)) {
                _this._sessions.pushBack(model);
            }
        });
        this.refreshed.emit(void 0);
    };
    /**
     * Handle a change on the contents manager.
     */
    FileBrowserModel.prototype._onFileChanged = function (sender, change) {
        var path = this._model.path || '.';
        var value = change.oldValue;
        if (value && value.path && services_1.ContentsManager.dirname(value.path) === path) {
            this.fileChanged.emit(change);
            this._scheduleUpdate();
            return;
        }
        value = change.newValue;
        if (value && value.path && services_1.ContentsManager.dirname(value.path) === path) {
            this.fileChanged.emit(change);
            this._scheduleUpdate();
            return;
        }
    };
    /**
     * Handle internal model refresh logic.
     */
    FileBrowserModel.prototype._scheduleUpdate = function () {
        var _this = this;
        // Send immediately if there is no pending action, otherwise defer.
        if (this._blackoutId !== -1) {
            this._requested = true;
            return;
        }
        this._timeoutId = setTimeout(function () {
            _this.cd('.');
            if (_this._requested && _this._blackoutId !== -1) {
                _this._requested = false;
                clearTimeout(_this._blackoutId);
                _this._timeoutId = setTimeout(function () {
                    _this._scheduleUpdate();
                }, MIN_REFRESH);
            }
            else {
                _this._blackoutId = setTimeout(function () {
                    _this._blackoutId = -1;
                    if (_this._requested) {
                        _this._scheduleUpdate();
                    }
                }, MIN_REFRESH);
            }
        }, 0);
    };
    return FileBrowserModel;
}());
exports.FileBrowserModel = FileBrowserModel;
// Define the signals for the `FileBrowserModel` class.
signaling_1.defineSignal(FileBrowserModel.prototype, 'pathChanged');
signaling_1.defineSignal(FileBrowserModel.prototype, 'refreshed');
signaling_1.defineSignal(FileBrowserModel.prototype, 'fileChanged');
/**
 * The namespace for the file browser model private data.
 */
var Private;
(function (Private) {
    /**
     * Parse the content of a `FileReader`.
     *
     * If the result is an `ArrayBuffer`, return a Base64-encoded string.
     * Otherwise, return the JSON parsed result.
     */
    function getContent(reader) {
        if (reader.result instanceof ArrayBuffer) {
            // Base64-encode binary file data.
            var bytes = '';
            var buf = new Uint8Array(reader.result);
            var nbytes = buf.byteLength;
            for (var i = 0; i < nbytes; i++) {
                bytes += String.fromCharCode(buf[i]);
            }
            return btoa(bytes);
        }
        else {
            return JSON.parse(reader.result);
        }
    }
    Private.getContent = getContent;
    /**
     * Normalize a path based on a root directory, accounting for relative paths.
     */
    function normalizePath(root, path) {
        return services_1.ContentsManager.getAbsolutePath(path, root);
    }
    Private.normalizePath = normalizePath;
})(Private || (Private = {}));
//# sourceMappingURL=model.js.map