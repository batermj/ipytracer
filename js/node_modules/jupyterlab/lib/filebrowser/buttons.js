// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var disposable_1 = require('phosphor/lib/core/disposable');
var menu_1 = require('phosphor/lib/ui/menu');
var widget_1 = require('phosphor/lib/ui/widget');
var dialog_1 = require('../dialog');
var dialogs_1 = require('./dialogs');
var utils = require('./utils');
/**
 * The class name added to a file buttons widget.
 */
var FILE_BUTTONS_CLASS = 'jp-FileButtons';
/**
 * The class name added to a button node.
 */
var BUTTON_CLASS = 'jp-FileButtons-button';
/**
 * The class name added to a button content node.
 */
var CONTENT_CLASS = 'jp-FileButtons-buttonContent';
/**
 * The class name added to a button icon node.
 */
var ICON_CLASS = 'jp-FileButtons-buttonIcon';
/**
 * The class name added to the create button.
 */
var CREATE_CLASS = 'jp-id-create';
/**
 * The class name added to the upload button.
 */
var UPLOAD_CLASS = 'jp-id-upload';
/**
 * The class name added to the refresh button.
 */
var REFRESH_CLASS = 'jp-id-refresh';
/**
 * The class name added to an active create button.
 */
var ACTIVE_CLASS = 'jp-mod-active';
/**
 * The class name added to a dropdown icon.
 */
var DROPDOWN_CLASS = 'jp-FileButtons-dropdownIcon';
/**
 * A widget which hosts the file browser buttons.
 */
var FileButtons = (function (_super) {
    __extends(FileButtons, _super);
    /**
     * Construct a new file browser buttons widget.
     */
    function FileButtons(options) {
        var _this = this;
        _super.call(this);
        /**
         * The 'mousedown' handler for the create button.
         */
        this._onCreateButtonPressed = function (event) {
            // Do nothing if nothing if it's not a left press.
            if (event.button !== 0) {
                return;
            }
            // Do nothing if the create button is already active.
            var button = _this._buttons.create;
            if (button.classList.contains(ACTIVE_CLASS)) {
                return;
            }
            // Create a new dropdown menu and snap the button geometry.
            var commands = _this._commands;
            var keymap = _this._keymap;
            var dropdown = Private.createDropdownMenu(_this, commands, keymap);
            var rect = button.getBoundingClientRect();
            // Mark the button as active.
            button.classList.add(ACTIVE_CLASS);
            // Setup the `aboutToClose` signal handler. The menu is disposed on an
            // animation frame to allow a mouse press event which closed the
            // menu to run its course. This keeps the button from re-opening.
            dropdown.aboutToClose.connect(function () {
                requestAnimationFrame(function () { dropdown.dispose(); });
            });
            // Setup the `disposed` signal handler. This restores the button
            // to the non-active state and allows a new menu to be opened.
            dropdown.disposed.connect(function () {
                button.classList.remove(ACTIVE_CLASS);
            });
            // Popup the menu aligned with the bottom of the create button.
            dropdown.open(rect.left, rect.bottom, { forceX: false, forceY: false });
        };
        /**
         * The 'click' handler for the upload button.
         */
        this._onUploadButtonClicked = function (event) {
            if (event.button !== 0) {
                return;
            }
            _this._input.click();
        };
        /**
         * The 'click' handler for the refresh button.
         */
        this._onRefreshButtonClicked = function (event) {
            if (event.button !== 0) {
                return;
            }
            // Force a refresh of the current directory.
            _this._model.cd('.');
        };
        /**
         * The 'change' handler for the input field.
         */
        this._onInputChanged = function () {
            var files = Array.prototype.slice.call(_this._input.files);
            Private.uploadFiles(_this, files);
        };
        this._buttons = Private.createButtons();
        this._commands = null;
        this._input = Private.createUploadInput();
        this._keymap = null;
        this._manager = null;
        this.addClass(FILE_BUTTONS_CLASS);
        this._model = options.model;
        this._buttons.create.onmousedown = this._onCreateButtonPressed;
        this._buttons.upload.onclick = this._onUploadButtonClicked;
        this._buttons.refresh.onclick = this._onRefreshButtonClicked;
        this._input.onchange = this._onInputChanged;
        var node = this.node;
        node.appendChild(this._buttons.create);
        node.appendChild(this._buttons.upload);
        node.appendChild(this._buttons.refresh);
        this._commands = options.commands;
        this._keymap = options.keymap;
        this._manager = options.manager;
    }
    /**
     * Dispose of the resources held by the widget.
     */
    FileButtons.prototype.dispose = function () {
        this._buttons = null;
        this._commands = null;
        this._input = null;
        this._keymap = null;
        this._manager = null;
        this._model = null;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(FileButtons.prototype, "model", {
        /**
         * Get the model used by the widget.
         */
        get: function () {
            return this._model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileButtons.prototype, "manager", {
        /**
         * Get the document manager used by the widget.
         */
        get: function () {
            return this._manager;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create a file from a creator.
     *
     * @param creatorName - The name of the file creator.
     *
     * @returns A promise that resolves with the created widget.
     */
    FileButtons.prototype.createFrom = function (creatorName) {
        return dialogs_1.createFromDialog(this.model, this.manager, creatorName);
    };
    /**
     * Open a file by path.
     *
     * @param path - The path of the file.
     *
     * @param widgetName - The name of the widget factory to use.
     *
     * @param kernel - The kernel model to use.
     *
     * @return The widget for the path.
     */
    FileButtons.prototype.open = function (path, widgetName, kernel) {
        if (widgetName === void 0) { widgetName = 'default'; }
        var widget = this._manager.findWidget(path, widgetName);
        if (!widget) {
            widget = this._manager.open(path, widgetName, kernel);
        }
        return widget;
    };
    /**
     * Create a new file by path.
     *
     * @param path - The path of the file.
     *
     * @param widgetName - The name of the widget factory to use.
     *
     * @param kernel - The kernel model to use.
     *
     * @return The widget for the path.
     */
    FileButtons.prototype.createNew = function (path, widgetName, kernel) {
        if (widgetName === void 0) { widgetName = 'default'; }
        return this._manager.createNew(path, widgetName, kernel);
    };
    return FileButtons;
}(widget_1.Widget));
exports.FileButtons = FileButtons;
/**
 * The namespace for the `FileButtons` private data.
 */
var Private;
(function (Private) {
    /**
     * The ID counter prefix for new commands.
     *
     * #### Notes
     * Even though the commands are disposed when the dropdown menu is disposed,
     * in order to guarantee there are no race conditions with other `FileButtons`
     * instances, each set of commands is prefixed.
     */
    var id = 0;
    /**
     * Create the button group for a file buttons widget.
     */
    function createButtons() {
        var create = document.createElement('button');
        var upload = document.createElement('button');
        var refresh = document.createElement('button');
        var createContent = document.createElement('span');
        var uploadContent = document.createElement('span');
        var refreshContent = document.createElement('span');
        var createIcon = document.createElement('span');
        var uploadIcon = document.createElement('span');
        var refreshIcon = document.createElement('span');
        var dropdownIcon = document.createElement('span');
        create.type = 'button';
        upload.type = 'button';
        refresh.type = 'button';
        create.title = 'Create New...';
        upload.title = 'Upload File(s)';
        refresh.title = 'Refresh File List';
        create.className = BUTTON_CLASS + " " + CREATE_CLASS;
        upload.className = BUTTON_CLASS + " " + UPLOAD_CLASS;
        refresh.className = BUTTON_CLASS + " " + REFRESH_CLASS;
        createContent.className = CONTENT_CLASS;
        uploadContent.className = CONTENT_CLASS;
        refreshContent.className = CONTENT_CLASS;
        // TODO make these icons configurable.
        createIcon.className = ICON_CLASS + ' fa fa-plus';
        uploadIcon.className = ICON_CLASS + ' fa fa-upload';
        refreshIcon.className = ICON_CLASS + ' fa fa-refresh';
        dropdownIcon.className = DROPDOWN_CLASS + ' fa fa-caret-down';
        createContent.appendChild(createIcon);
        createContent.appendChild(dropdownIcon);
        uploadContent.appendChild(uploadIcon);
        refreshContent.appendChild(refreshIcon);
        create.appendChild(createContent);
        upload.appendChild(uploadContent);
        refresh.appendChild(refreshContent);
        return { create: create, upload: upload, refresh: refresh };
    }
    Private.createButtons = createButtons;
    /**
     * Create the upload input node for a file buttons widget.
     */
    function createUploadInput() {
        var input = document.createElement('input');
        input.type = 'file';
        input.multiple = true;
        return input;
    }
    Private.createUploadInput = createUploadInput;
    /**
     * Create a new folder.
     */
    function createNewFolder(widget) {
        widget.model.newUntitled({ type: 'directory' }).catch(function (error) {
            utils.showErrorMessage('New Folder Error', error);
        });
    }
    Private.createNewFolder = createNewFolder;
    /**
     * Create a new dropdown menu for the create new button.
     */
    function createDropdownMenu(widget, commands, keymap) {
        var menu = new menu_1.Menu({ commands: commands, keymap: keymap });
        var prefix = "file-buttons-" + ++id;
        var disposables = new disposable_1.DisposableSet();
        var registry = widget.manager.registry;
        var command;
        // Remove all the commands associated with this menu upon disposal.
        menu.disposed.connect(function () { return disposables.dispose(); });
        command = prefix + ":new-text-folder";
        disposables.add(commands.addCommand(command, {
            execute: function () { createNewFolder(widget); },
            label: 'Folder'
        }));
        menu.addItem({ command: command });
        iteration_1.each(registry.creators(), function (creator) {
            command = prefix + ":new-" + creator.name;
            disposables.add(commands.addCommand(command, {
                execute: function () {
                    widget.createFrom(creator.name);
                },
                label: creator.name
            }));
            menu.addItem({ command: command });
        });
        return menu;
    }
    Private.createDropdownMenu = createDropdownMenu;
    /**
     * Upload an array of files to the server.
     */
    function uploadFiles(widget, files) {
        var pending = files.map(function (file) { return uploadFile(widget, file); });
        Promise.all(pending).catch(function (error) {
            utils.showErrorMessage('Upload Error', error);
        });
    }
    Private.uploadFiles = uploadFiles;
    /**
     * Upload a file to the server.
     */
    function uploadFile(widget, file) {
        return widget.model.upload(file).catch(function (error) {
            var exists = error.message.indexOf('already exists') !== -1;
            if (exists) {
                return uploadFileOverride(widget, file);
            }
            throw error;
        });
    }
    /**
     * Upload a file to the server checking for override.
     */
    function uploadFileOverride(widget, file) {
        var options = {
            title: 'Overwrite File?',
            body: "\"" + file.name + "\" already exists, overwrite?"
        };
        return dialog_1.showDialog(options).then(function (button) {
            if (button.text !== 'Ok') {
                return;
            }
            return widget.model.upload(file, true);
        });
    }
})(Private || (Private = {}));
//# sourceMappingURL=buttons.js.map