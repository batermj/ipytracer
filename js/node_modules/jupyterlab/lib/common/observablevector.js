// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var searching_1 = require('phosphor/lib/algorithm/searching');
var vector_1 = require('phosphor/lib/collections/vector');
var signaling_1 = require('phosphor/lib/core/signaling');
/**
 * A concrete implementation of [[IObservableVector]].
 */
var ObservableVector = (function (_super) {
    __extends(ObservableVector, _super);
    function ObservableVector() {
        _super.apply(this, arguments);
        this._isDisposed = false;
    }
    Object.defineProperty(ObservableVector.prototype, "isDisposed", {
        /**
         * Test whether the vector has been disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the vector.
     */
    ObservableVector.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.clear();
        signaling_1.clearSignalData(this);
    };
    /**
     * Set the value at the specified index.
     *
     * @param index - The positive integer index of interest.
     *
     * @param value - The value to set at the specified index.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Undefined Behavior
     * An `index` which is non-integral or out of range.
     */
    ObservableVector.prototype.set = function (index, value) {
        var oldValues = [this.at(index)];
        _super.prototype.set.call(this, index, value);
        this.changed.emit({
            type: 'set',
            oldIndex: index,
            newIndex: index,
            oldValues: oldValues,
            newValues: [value]
        });
    };
    /**
     * Add a value to the back of the vector.
     *
     * @param value - The value to add to the back of the vector.
     *
     * @returns The new length of the vector.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     */
    ObservableVector.prototype.pushBack = function (value) {
        var num = _super.prototype.pushBack.call(this, value);
        this.changed.emit({
            type: 'add',
            oldIndex: -1,
            newIndex: this.length - 1,
            oldValues: [],
            newValues: [value]
        });
        return num;
    };
    /**
     * Remove and return the value at the back of the vector.
     *
     * @returns The value at the back of the vector, or `undefined` if
     *   the vector is empty.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * Iterators pointing at the removed value are invalidated.
     */
    ObservableVector.prototype.popBack = function () {
        var value = _super.prototype.popBack.call(this);
        this.changed.emit({
            type: 'remove',
            oldIndex: this.length,
            newIndex: -1,
            oldValues: [value],
            newValues: []
        });
        return value;
    };
    /**
     * Insert a value into the vector at a specific index.
     *
     * @param index - The index at which to insert the value.
     *
     * @param value - The value to set at the specified index.
     *
     * @returns The new length of the vector.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Notes
     * The `index` will be clamped to the bounds of the vector.
     *
     * #### Undefined Behavior
     * An `index` which is non-integral.
     */
    ObservableVector.prototype.insert = function (index, value) {
        var num = _super.prototype.insert.call(this, index, value);
        this.changed.emit({
            type: 'add',
            oldIndex: -1,
            newIndex: index,
            oldValues: [],
            newValues: [value]
        });
        return num;
    };
    /**
     * Remove the first occurrence of a value from the vector.
     *
     * @param value - The value of interest.
     *
     * @returns The index of the removed value, or `-1` if the value
     *   is not contained in the vector.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * Iterators pointing at the removed value and beyond are invalidated.
     *
     * #### Notes
     * Comparison is performed using strict `===` equality.
     */
    ObservableVector.prototype.remove = function (value) {
        var index = searching_1.indexOf(this, value);
        this.removeAt(index);
        return index;
    };
    /**
     * Remove and return the value at a specific index.
     *
     * @param index - The index of the value of interest.
     *
     * @returns The value at the specified index, or `undefined` if the
     *   index is out of range.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * Iterators pointing at the removed value and beyond are invalidated.
     *
     * #### Undefined Behavior
     * An `index` which is non-integral.
     */
    ObservableVector.prototype.removeAt = function (index) {
        var value = _super.prototype.removeAt.call(this, index);
        this.changed.emit({
            type: 'remove',
            oldIndex: index,
            newIndex: -1,
            oldValues: [value],
            newValues: []
        });
        return value;
    };
    /**
     * Remove all values from the vector.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * All current iterators are invalidated.
     */
    ObservableVector.prototype.clear = function () {
        var oldValues = iteration_1.toArray(this);
        _super.prototype.clear.call(this);
        this.changed.emit({
            type: 'remove',
            oldIndex: 0,
            newIndex: 0,
            oldValues: oldValues,
            newValues: []
        });
    };
    /**
     * Move a value from one index to another.
     *
     * @parm fromIndex - The index of the element to move.
     *
     * @param toIndex - The index to move the element to.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`
     * and beyond are invalidated.
     *
     * #### Undefined Behavior
     * A `fromIndex` or a `toIndex` which is non-integral.
     */
    ObservableVector.prototype.move = function (fromIndex, toIndex) {
        var value = this.at(fromIndex);
        _super.prototype.removeAt.call(this, fromIndex);
        if (toIndex < fromIndex) {
            _super.prototype.insert.call(this, toIndex - 1, value);
        }
        else {
            _super.prototype.insert.call(this, toIndex, value);
        }
        var arr = [value];
        this.changed.emit({
            type: 'move',
            oldIndex: fromIndex,
            newIndex: toIndex,
            oldValues: arr,
            newValues: arr
        });
    };
    /**
     * Push a set of values to the back of the vector.
     *
     * @param values - An iterable or array-like set of values to add.
     *
     * @returns The new length of the vector.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * No changes.
     */
    ObservableVector.prototype.pushAll = function (values) {
        var _this = this;
        var newIndex = this.length;
        var newValues = iteration_1.toArray(values);
        iteration_1.each(newValues, function (value) { _super.prototype.pushBack.call(_this, value); });
        this.changed.emit({
            type: 'add',
            oldIndex: -1,
            newIndex: newIndex,
            oldValues: [],
            newValues: newValues
        });
        return this.length;
    };
    /**
     * Insert a set of items into the vector at the specified index.
     *
     * @param index - The index at which to insert the values.
     *
     * @param values - The values to insert at the specified index.
     *
     * @returns The new length of the vector.
     *
     * #### Complexity.
     * Linear.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Notes
     * The `index` will be clamped to the bounds of the vector.
     *
     * #### Undefined Behavior.
     * An `index` which is non-integral.
     */
    ObservableVector.prototype.insertAll = function (index, values) {
        var _this = this;
        var newIndex = index;
        var newValues = iteration_1.toArray(values);
        iteration_1.each(newValues, function (value) { _super.prototype.insert.call(_this, index++, value); });
        this.changed.emit({
            type: 'add',
            oldIndex: -1,
            newIndex: newIndex,
            oldValues: [],
            newValues: newValues
        });
        return this.length;
    };
    /**
     * Remove a range of items from the vector.
     *
     * @param startIndex - The start index of the range to remove (inclusive).
     *
     * @param endIndex - The end index of the range to remove (exclusive).
     *
     * @returns The new length of the vector.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * Iterators pointing to the first removed value and beyond are invalid.
     *
     * #### Undefined Behavior
     * A `startIndex` or `endIndex` which is non-integral.
     */
    ObservableVector.prototype.removeRange = function (startIndex, endIndex) {
        var oldValues = [];
        for (var i = startIndex; i < endIndex; i++) {
            oldValues.push(_super.prototype.removeAt.call(this, startIndex));
        }
        this.changed.emit({
            type: 'remove',
            oldIndex: startIndex,
            newIndex: -1,
            oldValues: oldValues,
            newValues: []
        });
        return this.length;
    };
    return ObservableVector;
}(vector_1.Vector));
exports.ObservableVector = ObservableVector;
// Define the signals for the `ObservableVector` class.
signaling_1.defineSignal(ObservableVector.prototype, 'changed');
//# sourceMappingURL=observablevector.js.map