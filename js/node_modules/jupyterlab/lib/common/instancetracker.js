// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var signaling_1 = require('phosphor/lib/core/signaling');
/**
 * A class that keeps track of widget instances.
 *
 * #### Notes
 * This is meant to be used in conjunction with a `FocusTracker` and will
 * typically be kept in sync with focus tracking events.
 */
var InstanceTracker = (function () {
    function InstanceTracker() {
        this._currentWidget = null;
        this._widgets = new Set();
    }
    Object.defineProperty(InstanceTracker.prototype, "currentWidget", {
        /**
         * The current widget is the most recently focused widget.
         */
        get: function () {
            return this._currentWidget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstanceTracker.prototype, "isDisposed", {
        /**
         * Test whether the tracker is disposed.
         */
        get: function () {
            return this._widgets === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add a new widget to the tracker.
     */
    InstanceTracker.prototype.add = function (widget) {
        var _this = this;
        if (this._widgets.has(widget)) {
            console.warn(widget.id + " has already been added to the tracker.");
            return;
        }
        this._widgets.add(widget);
        widget.disposed.connect(function () {
            _this._widgets.delete(widget);
            if (!_this._widgets.size) {
                _this._currentWidget = null;
                _this.onCurrentChanged();
                _this.currentChanged.emit(null);
            }
        });
    };
    /**
     * Dispose of the resources held by the tracker.
     */
    InstanceTracker.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        signaling_1.clearSignalData(this);
        this._currentWidget = null;
        this._widgets.clear();
        this._widgets = null;
    };
    /**
     * Find the first widget in the tracker that satisfies a filter function.
     *
     * @param fn The filter function to call on each widget.
     */
    InstanceTracker.prototype.find = function (fn) {
        var result = null;
        this._widgets.forEach(function (widget) {
            // If a result has already been found, short circuit.
            if (result) {
                return;
            }
            if (fn(widget)) {
                result = widget;
            }
        });
        return result;
    };
    /**
     * Iterate through each widget in the tracker.
     *
     * @param fn The function to call on each widget.
     */
    InstanceTracker.prototype.forEach = function (fn) {
        this._widgets.forEach(function (widget) { fn(widget); });
    };
    /**
     * Check if this tracker has the specified widget.
     */
    InstanceTracker.prototype.has = function (widget) {
        return this._widgets.has(widget);
    };
    /**
     * Syncs the state of the tracker with a widget known to have focus.
     *
     * @param current The currently focused widget.
     *
     * @returns The current widget or `null` if there is none.
     *
     * #### Notes
     * Syncing acts as a gate returning a widget only if it is the current widget.
     */
    InstanceTracker.prototype.sync = function (current) {
        if (this.isDisposed) {
            return;
        }
        if (current && this._widgets.has(current)) {
            // If no state change needs to occur, just bail.
            if (this._currentWidget === current) {
                return this._currentWidget;
            }
            this._currentWidget = current;
            this.onCurrentChanged();
            this.currentChanged.emit(this._currentWidget);
            return this._currentWidget;
        }
        return null;
    };
    /**
     * Handle the current change event.
     *
     * #### Notes
     * The default implementation is a no-op. This may be reimplemented by
     * subclasses to customize the behavior.
     */
    InstanceTracker.prototype.onCurrentChanged = function () {
        /* This is a no-op. */
    };
    return InstanceTracker;
}());
exports.InstanceTracker = InstanceTracker;
// Define the signals for the `InstanceTracker` class.
signaling_1.defineSignal(InstanceTracker.prototype, 'currentChanged');
//# sourceMappingURL=instancetracker.js.map