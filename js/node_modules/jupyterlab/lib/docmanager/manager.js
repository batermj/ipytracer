// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var services_1 = require('@jupyterlab/services');
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var searching_1 = require('phosphor/lib/algorithm/searching');
var vector_1 = require('phosphor/lib/collections/vector');
var properties_1 = require('phosphor/lib/core/properties');
var docregistry_1 = require('../docregistry');
var savehandler_1 = require('./savehandler');
var widgetmanager_1 = require('./widgetmanager');
/**
 * The document manager.
 *
 * #### Notes
 * The document manager is used to register model and widget creators,
 * and the file browser uses the document manager to create widgets. The
 * document manager maintains a context for each path and model type that is
 * open, and a list of widgets for each context. The document manager is in
 * control of the proper closing and disposal of the widgets and contexts.
 */
var DocumentManager = (function () {
    /**
     * Construct a new document manager.
     */
    function DocumentManager(options) {
        this._serviceManager = null;
        this._widgetManager = null;
        this._registry = null;
        this._contexts = new vector_1.Vector();
        this._opener = null;
        this._registry = options.registry;
        this._serviceManager = options.manager;
        this._opener = options.opener;
        this._widgetManager = new widgetmanager_1.DocumentWidgetManager({
            registry: this._registry
        });
    }
    Object.defineProperty(DocumentManager.prototype, "registry", {
        /**
         * Get the registry used by the manager.
         */
        get: function () {
            return this._registry;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentManager.prototype, "services", {
        /**
         * Get the service manager used by the manager.
         */
        get: function () {
            return this._serviceManager;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentManager.prototype, "isDisposed", {
        /**
         * Get whether the document manager has been disposed.
         */
        get: function () {
            return this._serviceManager === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the document manager.
     */
    DocumentManager.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._serviceManager = null;
        iteration_1.each(this._contexts, function (context) {
            context.dispose();
        });
        this._contexts.clear();
        this._widgetManager = null;
    };
    /**
     * Open a file and return the widget used to view it.
     *
     * @param path - The file path to open.
     *
     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.
     *
     * @param kernel - An optional kernel name/id to override the default.
     *
     * @returns The created widget, or `undefined`.
     *
     * #### Notes
     * This function will return `undefined` if a valid widget factory
     * cannot be found.
     */
    DocumentManager.prototype.open = function (path, widgetName, kernel) {
        if (widgetName === void 0) { widgetName = 'default'; }
        var widgetFactory = this._widgetFactoryFor(path, widgetName);
        if (!widgetFactory) {
            return;
        }
        var factory = this._registry.getModelFactory(widgetFactory.modelName);
        if (!factory) {
            return;
        }
        // Use an existing context if available.
        var context = this._findContext(path, factory.name);
        if (!context) {
            context = this._createContext(path, factory);
            // Load the contents from disk.
            context.revert();
        }
        // Handle the kernel for the context.
        if (kernel && widgetFactory.canStartKernel) {
            context.changeKernel(kernel);
        }
        else if (widgetFactory.preferKernel && !context.kernel) {
            context.startDefaultKernel();
        }
        var widget = this._widgetManager.createWidget(widgetFactory.name, context);
        this._opener.open(widget);
        return widget;
    };
    /**
     * Create a new file and return the widget used to view it.
     *
     * @param path - The file path to create.
     *
     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.
     *
     * @param kernel - An optional kernel name/id to override the default.
     *
     * @returns The created widget, or `undefined`.
     *
     * #### Notes
     * This function will return `undefined` if a valid widget factory
     * cannot be found.
     */
    DocumentManager.prototype.createNew = function (path, widgetName, kernel) {
        if (widgetName === void 0) { widgetName = 'default'; }
        var widgetFactory = this._widgetFactoryFor(path, widgetName);
        if (!widgetFactory) {
            return;
        }
        var factory = this._registry.getModelFactory(widgetFactory.modelName);
        if (!factory) {
            return;
        }
        var context = this._createContext(path, factory);
        // Immediately save the contents to disk.
        context.save();
        // Handle the kernel for the context.
        if (kernel && widgetFactory.canStartKernel) {
            context.changeKernel(kernel);
        }
        else if (widgetFactory.preferKernel && !context.kernel) {
            context.startDefaultKernel();
        }
        var widget = this._widgetManager.createWidget(widgetFactory.name, context);
        this._opener.open(widget);
        return widget;
    };
    /**
     * See if a widget already exists for the given path and widget name.
     *
     * @param path - The file path to use.
     *
     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.
     *
     * @returns The found widget, or `undefined`.
     *
     * #### Notes
     * This can be used to use an existing widget instead of opening
     * a new widget.
     */
    DocumentManager.prototype.findWidget = function (path, widgetName) {
        if (widgetName === void 0) { widgetName = 'default'; }
        if (widgetName === 'default') {
            var factory = this._registry.defaultWidgetFactory(services_1.ContentsManager.extname(path));
            if (!factory) {
                return;
            }
            widgetName = factory.name;
        }
        var context = this._contextForPath(path);
        if (context) {
            return this._widgetManager.findWidget(context, widgetName);
        }
    };
    /**
     * Get the document context for a widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The context associated with the widget, or `undefined`.
     */
    DocumentManager.prototype.contextForWidget = function (widget) {
        return this._widgetManager.contextForWidget(widget);
    };
    /**
     * Clone a widget.
     *
     * @param widget - The source widget.
     *
     * @returns A new widget or `undefined`.
     *
     * #### Notes
     *  Uses the same widget factory and context as the source, or returns
     *  `undefined` if the source widget is not managed by this manager.
     */
    DocumentManager.prototype.cloneWidget = function (widget) {
        return this._widgetManager.cloneWidget(widget);
    };
    /**
     * Close the widgets associated with a given path.
     *
     * @param path - The target path.
     */
    DocumentManager.prototype.closeFile = function (path) {
        var context = this._contextForPath(path);
        if (context) {
            this._widgetManager.closeWidgets(context);
        }
    };
    /**
     * Close all of the open documents.
     */
    DocumentManager.prototype.closeAll = function () {
        var _this = this;
        iteration_1.each(iteration_1.toArray(this._contexts), function (context) {
            _this._widgetManager.closeWidgets(context);
        });
    };
    /**
     * Find a context for a given path and factory name.
     */
    DocumentManager.prototype._findContext = function (path, factoryName) {
        return searching_1.find(this._contexts, function (context) {
            return (context.factoryName === factoryName &&
                context.path === path);
        });
    };
    /**
     * Get a context for a given path.
     */
    DocumentManager.prototype._contextForPath = function (path) {
        return searching_1.find(this._contexts, function (context) {
            return context.path === path;
        });
    };
    /**
     * Create a context from a path and a model factory.
     */
    DocumentManager.prototype._createContext = function (path, factory) {
        var _this = this;
        var adopter = function (widget) {
            _this._widgetManager.adoptWidget(context, widget);
            _this._opener.open(widget);
        };
        var context = new docregistry_1.Context({
            opener: adopter,
            manager: this._serviceManager,
            factory: factory,
            path: path
        });
        var handler = new savehandler_1.SaveHandler({
            context: context,
            manager: this._serviceManager
        });
        Private.saveHandlerProperty.set(context, handler);
        context.ready.then(function () {
            handler.start();
        });
        context.disposed.connect(function () {
            _this._contexts.remove(context);
        });
        this._contexts.pushBack(context);
        return context;
    };
    /**
     * Get the model factory for a given widget name.
     */
    DocumentManager.prototype._widgetFactoryFor = function (path, widgetName) {
        var registry = this._registry;
        if (widgetName === 'default') {
            widgetName = registry.defaultWidgetFactory(services_1.ContentsManager.extname(path)).name;
        }
        return registry.getWidgetFactory(widgetName);
    };
    return DocumentManager;
}());
exports.DocumentManager = DocumentManager;
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * An attached property for a context save handler.
     */
    Private.saveHandlerProperty = new properties_1.AttachedProperty({
        name: 'saveHandler'
    });
})(Private || (Private = {}));
//# sourceMappingURL=manager.js.map