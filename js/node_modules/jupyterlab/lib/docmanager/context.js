// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var jupyter_js_services_1 = require('jupyter-js-services');
var searching_1 = require('phosphor/lib/algorithm/searching');
var disposable_1 = require('phosphor/lib/core/disposable');
var signaling_1 = require('phosphor/lib/core/signaling');
var dialog_1 = require('../dialog');
var savehandler_1 = require('./savehandler');
/**
 * An implementation of a document context.
 *
 * This class is typically instantiated by the document manger.
 */
var Context = (function () {
    /**
     * Construct a new document context.
     */
    function Context(options) {
        this._manager = null;
        this._opener = null;
        this._model = null;
        this._path = '';
        this._session = null;
        this._factory = null;
        this._saver = null;
        this._isPopulated = false;
        this._contentsModel = null;
        var manager = this._manager = options.manager;
        this._factory = options.factory;
        this._opener = options.opener;
        this._path = options.path;
        var ext = jupyter_js_services_1.ContentsManager.extname(this._path);
        var lang = this._factory.preferredLanguage(ext);
        this._model = this._factory.createNew(lang);
        manager.sessions.runningChanged.connect(this._onSessionsChanged, this);
        this._saver = new savehandler_1.SaveHandler({ context: this, manager: manager });
    }
    Object.defineProperty(Context.prototype, "model", {
        /**
         * Get the model associated with the document.
         *
         * #### Notes
         * This is a read-only property
         */
        get: function () {
            return this._model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "kernel", {
        /**
         * The current kernel associated with the document.
         *
         * #### Notes
         * This is a read-only propery.
         */
        get: function () {
            return this._session ? this._session.kernel : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "path", {
        /**
         * The current path associated with the document.
         */
        get: function () {
            return this._path;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "contentsModel", {
        /**
         * The current contents model associated with the document
         *
         * #### Notes
         * This is a read-only property.  The model will have an
         * empty `contents` field.
         */
        get: function () {
            return this._contentsModel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "kernelspecs", {
        /**
         * Get the kernel spec information.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._manager.kernelspecs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "isPopulated", {
        /**
         * Test whether the context is fully populated.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._isPopulated;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "factoryName", {
        /**
         * Get the model factory name.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this.isDisposed ? '' : this._factory.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "isDisposed", {
        /**
         * Test whether the context has been disposed (read-only).
         */
        get: function () {
            return this._manager === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the context.
     */
    Context.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this.disposed.emit(void 0);
        signaling_1.clearSignalData(this);
        this._model.dispose();
        this._manager = null;
        this._factory = null;
    };
    /**
     * Change the current kernel associated with the document.
     */
    Context.prototype.changeKernel = function (options) {
        var _this = this;
        var session = this._session;
        if (options) {
            if (session) {
                return session.changeKernel(options);
            }
            else {
                var path = this._path;
                var sOptions = {
                    path: path,
                    kernelName: options.name,
                    kernelId: options.id
                };
                return this._startSession(sOptions);
            }
        }
        else {
            if (session) {
                return session.shutdown().then(function () {
                    session.dispose();
                    _this._session = null;
                    _this.kernelChanged.emit(null);
                    return void 0;
                });
            }
            else {
                return Promise.resolve(void 0);
            }
        }
    };
    /**
     * Set the path of the context.
     *
     * #### Notes
     * This is not intended to be called by the user.
     * It is assumed that the file has been renamed on the
     * contents manager prior to this operation.
     */
    Context.prototype.setPath = function (value) {
        this._path = value;
        var session = this._session;
        if (session) {
            session.rename(value);
        }
        this.pathChanged.emit(value);
    };
    /**
     * Save the document contents to disk.
     */
    Context.prototype.save = function () {
        var _this = this;
        var model = this._model;
        var contents = this._contentsModel || {};
        var path = this._path;
        contents.type = this._factory.fileType;
        contents.format = this._factory.fileFormat;
        if (model.readOnly) {
            return Promise.reject(new Error('Read only'));
        }
        if (contents.format === 'json') {
            contents.content = model.toJSON();
        }
        else {
            contents.content = model.toString();
        }
        var promise = this._manager.contents.save(path, contents);
        return promise.then(function (contents) {
            _this._updateContentsModel(contents);
            model.dirty = false;
            if (!_this._isPopulated) {
                _this._populate();
            }
        }).catch(function (err) {
            dialog_1.showDialog({
                title: 'File Save Error',
                body: err.xhr.responseText,
                buttons: [dialog_1.okButton]
            });
        });
    };
    /**
     * Save the document to a different path chosen by the user.
     */
    Context.prototype.saveAs = function () {
        var _this = this;
        return Private.getSavePath(this._path).then(function (newPath) {
            if (!newPath) {
                return;
            }
            _this.setPath(newPath);
            var session = _this._session;
            if (session) {
                var options = {
                    path: newPath,
                    kernelId: session.kernel.id,
                    kernelName: session.kernel.name
                };
                return _this._startSession(options).then(function () {
                    return _this.save();
                });
            }
            return _this.save();
        });
    };
    /**
     * Revert the document contents to disk contents.
     */
    Context.prototype.revert = function () {
        var _this = this;
        var opts = {
            format: this._factory.fileFormat,
            type: this._factory.fileType,
            content: true
        };
        var path = this._path;
        var model = this._model;
        return this._manager.contents.get(path, opts).then(function (contents) {
            if (contents.format === 'json') {
                model.fromJSON(contents.content);
            }
            else {
                model.fromString(contents.content);
            }
            _this._updateContentsModel(contents);
            model.dirty = false;
            if (!_this._isPopulated) {
                _this._populate();
            }
        }).catch(function (err) {
            dialog_1.showDialog({
                title: 'File Load Error',
                body: err.xhr.responseText,
                buttons: [dialog_1.okButton]
            });
        });
    };
    /**
     * Create a checkpoint for the file.
     */
    Context.prototype.createCheckpoint = function () {
        return this._manager.contents.createCheckpoint(this._path);
    };
    /**
     * Delete a checkpoint for the file.
     */
    Context.prototype.deleteCheckpoint = function (checkpointID) {
        return this._manager.contents.deleteCheckpoint(this._path, checkpointID);
    };
    /**
     * Restore the file to a known checkpoint state.
     */
    Context.prototype.restoreCheckpoint = function (checkpointID) {
        var contents = this._manager.contents;
        var path = this._path;
        if (checkpointID) {
            return contents.restoreCheckpoint(path, checkpointID);
        }
        return this.listCheckpoints().then(function (checkpoints) {
            if (!checkpoints.length) {
                return;
            }
            checkpointID = checkpoints[checkpoints.length - 1].id;
            return contents.restoreCheckpoint(path, checkpointID);
        });
    };
    /**
     * List available checkpoints for a file.
     */
    Context.prototype.listCheckpoints = function () {
        return this._manager.contents.listCheckpoints(this._path);
    };
    /**
     * Get the list of running sessions.
     */
    Context.prototype.listSessions = function () {
        return this._manager.sessions.listRunning();
    };
    /**
     * Resolve a relative url to a correct server path.
     */
    Context.prototype.resolveUrl = function (url) {
        // Ignore urls that have a protocol.
        if (jupyter_js_services_1.utils.urlParse(url).protocol || url.indexOf('//') === 0) {
            return url;
        }
        var cwd = jupyter_js_services_1.ContentsManager.dirname(this._path);
        var path = jupyter_js_services_1.ContentsManager.getAbsolutePath(url, cwd);
        return this._manager.contents.getDownloadUrl(path);
    };
    /**
     * Add a sibling widget to the document manager.
     */
    Context.prototype.addSibling = function (widget) {
        var opener = this._opener;
        if (opener) {
            opener(widget);
        }
        return new disposable_1.DisposableDelegate(function () {
            widget.close();
        });
    };
    /**
     * Start a session and set up its signals.
     */
    Context.prototype._startSession = function (options) {
        var _this = this;
        return this._manager.sessions.startNew(options).then(function (session) {
            if (_this._session) {
                _this._session.dispose();
            }
            _this._session = session;
            _this.kernelChanged.emit(session.kernel);
            session.pathChanged.connect(function (s, path) {
                if (path !== _this._path) {
                    _this.setPath(path);
                }
            });
            session.kernelChanged.connect(function (s, kernel) {
                _this.kernelChanged.emit(kernel);
            });
            return session.kernel;
        });
    };
    /**
     * Update our contents model, without the content.
     */
    Context.prototype._updateContentsModel = function (model) {
        var newModel = {
            path: model.path,
            name: model.name,
            type: model.type,
            writable: model.writable,
            created: model.created,
            last_modified: model.last_modified,
            mimetype: model.mimetype,
            format: model.format
        };
        var prevModel = this._contentsModel;
        this._contentsModel = newModel;
        if (!prevModel || newModel.last_modified !== prevModel.last_modified) {
            this.contentsModelChanged.emit(newModel);
        }
    };
    /**
     * Handle a change to the running sessions.
     */
    Context.prototype._onSessionsChanged = function (sender, models) {
        var session = this._session;
        if (!session) {
            return;
        }
        var index = searching_1.findIndex(models, function (model) { return model.id === session.id; });
        if (index === -1) {
            session.dispose();
            this._session = null;
            this.kernelChanged.emit(null);
        }
    };
    /**
     * Handle an initial population.
     */
    Context.prototype._populate = function () {
        var _this = this;
        this._isPopulated = true;
        this._saver.start();
        // Add a checkpoint if none exists.
        this.listCheckpoints().then(function (checkpoints) {
            if (!checkpoints) {
                return _this.createCheckpoint();
            }
        }).then(function () {
            _this.populated.emit(void 0);
        });
    };
    return Context;
}());
exports.Context = Context;
// Define the signals for the `Context` class.
signaling_1.defineSignal(Context.prototype, 'kernelChanged');
signaling_1.defineSignal(Context.prototype, 'pathChanged');
signaling_1.defineSignal(Context.prototype, 'contentsModelChanged');
signaling_1.defineSignal(Context.prototype, 'populated');
signaling_1.defineSignal(Context.prototype, 'disposed');
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * Get a new file path from the user.
     */
    function getSavePath(path) {
        var input = document.createElement('input');
        input.value = path;
        return dialog_1.showDialog({
            title: 'Save File As..',
            body: input,
            okText: 'SAVE'
        }).then(function (result) {
            if (result.text === 'SAVE') {
                return input.value;
            }
        });
    }
    Private.getSavePath = getSavePath;
})(Private || (Private = {}));
//# sourceMappingURL=context.js.map