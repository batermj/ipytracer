// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var searching_1 = require('phosphor/lib/algorithm/searching');
var vector_1 = require('phosphor/lib/collections/vector');
var disposable_1 = require('phosphor/lib/core/disposable');
var messaging_1 = require('phosphor/lib/core/messaging');
var properties_1 = require('phosphor/lib/core/properties');
var signaling_1 = require('phosphor/lib/core/signaling');
var dates_1 = require('../common/dates');
var dialog_1 = require('../dialog');
/**
 * The class name added to document widgets.
 */
var DOCUMENT_CLASS = 'jp-Document';
/**
 * A class that maintains the lifecyle of file-backed widgets.
 */
var DocumentWidgetManager = (function () {
    /**
     * Construct a new document widget manager.
     */
    function DocumentWidgetManager(options) {
        this._closeGuard = false;
        this._registry = null;
        this._registry = options.registry;
    }
    Object.defineProperty(DocumentWidgetManager.prototype, "isDisposed", {
        /**
         * Test whether the document widget manager is disposed.
         */
        get: function () {
            return this._registry === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources used by the widget manager.
     */
    DocumentWidgetManager.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        signaling_1.disconnectReceiver(this);
        this._registry = null;
    };
    /**
     * Create a widget for a document and handle its lifecycle.
     *
     * @param name - The name of the widget factory.
     *
     * @param context - The document context object.
     *
     * @returns A widget created by the factory.
     *
     * @throws If the factory is not registered.
     */
    DocumentWidgetManager.prototype.createWidget = function (name, context) {
        var _this = this;
        var factory = this._registry.getWidgetFactory(name);
        if (!factory) {
            throw new Error("Factory is not registered: " + name);
        }
        var widget = factory.createNew(context);
        Private.nameProperty.set(widget, name);
        // Handle widget extensions.
        var disposables = new disposable_1.DisposableSet();
        iteration_1.each(this._registry.widgetExtensions(name), function (extender) {
            disposables.add(extender.createNew(widget, context));
        });
        widget.disposed.connect(function () {
            disposables.dispose();
        });
        this.adoptWidget(context, widget);
        context.fileChanged.connect(function () {
            _this.setCaption(widget);
        });
        context.ready.then(function () {
            _this.setCaption(widget);
        });
        return widget;
    };
    /**
     * Install the message hook for the widget and add to list
     * of known widgets.
     *
     * @param context - The document context object.
     *
     * @param widget - The widget to adopt.
     */
    DocumentWidgetManager.prototype.adoptWidget = function (context, widget) {
        var _this = this;
        var widgets = Private.widgetsProperty.get(context);
        widgets.pushBack(widget);
        messaging_1.installMessageHook(widget, function (handler, msg) {
            return _this.filterMessage(handler, msg);
        });
        widget.addClass(DOCUMENT_CLASS);
        widget.title.closable = true;
        widget.disposed.connect(function () {
            // Remove the widget.
            widgets.remove(widget);
            // Dispose of the context if this is the last widget using it.
            if (!widgets.length) {
                context.dispose();
            }
        });
        Private.contextProperty.set(widget, context);
    };
    /**
     * See if a widget already exists for the given context and widget name.
     *
     * @param context - The document context object.
     *
     * @returns The found widget, or `undefined`.
     *
     * #### Notes
     * This can be used to use an existing widget instead of opening
     * a new widget.
     */
    DocumentWidgetManager.prototype.findWidget = function (context, widgetName) {
        var widgets = Private.widgetsProperty.get(context);
        return searching_1.find(widgets, function (widget) {
            var name = Private.nameProperty.get(widget);
            if (name === widgetName) {
                return true;
            }
        });
    };
    /**
     * Get the document context for a widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The context associated with the widget, or `undefined`.
     */
    DocumentWidgetManager.prototype.contextForWidget = function (widget) {
        return Private.contextProperty.get(widget);
    };
    /**
     * Clone a widget.
     *
     * @param widget - The source widget.
     *
     * @returns A new widget or `undefined`.
     *
     * #### Notes
     *  Uses the same widget factory and context as the source, or returns
     *  `undefined` if the source widget is not managed by this manager.
     */
    DocumentWidgetManager.prototype.cloneWidget = function (widget) {
        var context = Private.contextProperty.get(widget);
        if (!context) {
            return;
        }
        var name = Private.nameProperty.get(widget);
        var newWidget = this.createWidget(name, context);
        this.adoptWidget(context, newWidget);
        return widget;
    };
    /**
     * Close the widgets associated with a given context.
     *
     * @param context - The document context object.
     */
    DocumentWidgetManager.prototype.closeWidgets = function (context) {
        var widgets = Private.widgetsProperty.get(context);
        iteration_1.each(widgets, function (widget) {
            widget.close();
        });
    };
    /**
     * Filter a message sent to a message handler.
     *
     * @param handler - The target handler of the message.
     *
     * @param msg - The message dispatched to the handler.
     *
     * @returns `false` if the message should be filtered, of `true`
     *   if the message should be dispatched to the handler as normal.
     */
    DocumentWidgetManager.prototype.filterMessage = function (handler, msg) {
        if (msg.type === 'close-request') {
            if (this._closeGuard) {
                return true;
            }
            this.onClose(handler);
            return false;
        }
        return true;
    };
    /**
     * Set the caption for widget title.
     *
     * @param widget - The target widget.
     */
    DocumentWidgetManager.prototype.setCaption = function (widget) {
        var context = Private.contextProperty.get(widget);
        var model = context.contentsModel;
        if (!model) {
            widget.title.caption = '';
            return;
        }
        context.listCheckpoints().then(function (checkpoints) {
            var last = checkpoints[checkpoints.length - 1];
            var checkpoint = last ? dates_1.dateTime(last.last_modified) : 'None';
            widget.title.caption = (("Name: " + model.name + "\n") +
                ("Path: " + model.path + "\n") +
                ("Last Saved: " + dates_1.dateTime(model.last_modified) + "\n") +
                ("Last Checkpoint: " + checkpoint));
        });
    };
    /**
     * Handle `'close-request'` messages.
     *
     * @param widget - The target widget.
     *
     * @returns A promise that resolves with whether the widget was closed.
     */
    DocumentWidgetManager.prototype.onClose = function (widget) {
        var _this = this;
        // Handle dirty state.
        return this._maybeClose(widget).then(function (result) {
            if (result) {
                _this._closeGuard = true;
                widget.close();
                _this._closeGuard = false;
                // Dispose of document widgets when they are closed.
                widget.dispose();
            }
            return result;
        }).catch(function () {
            widget.dispose();
        });
    };
    /**
     * Ask the user whether to close an unsaved file.
     */
    DocumentWidgetManager.prototype._maybeClose = function (widget) {
        // Bail if the model is not dirty or other widgets are using the model.
        var context = Private.contextProperty.get(widget);
        var widgets = Private.widgetsProperty.get(context);
        var model = context.model;
        if (!model.dirty || widgets.length > 1) {
            return Promise.resolve(true);
        }
        var fileName = widget.title.label;
        return dialog_1.showDialog({
            title: 'Close without saving?',
            body: "File \"" + fileName + "\" has unsaved changes, close without saving?",
            buttons: [dialog_1.cancelButton, dialog_1.warnButton]
        }).then(function (value) {
            if (value && value.text === 'OK') {
                return true;
            }
            return false;
        });
    };
    return DocumentWidgetManager;
}());
exports.DocumentWidgetManager = DocumentWidgetManager;
/**
 * A private namespace for DocumentManager data.
 */
var Private;
(function (Private) {
    /**
     * A private attached property for a widget context.
     */
    Private.contextProperty = new properties_1.AttachedProperty({
        name: 'context'
    });
    /**
     * A private attached property for a widget factory name.
     */
    Private.nameProperty = new properties_1.AttachedProperty({
        name: 'name'
    });
    /**
     * A private attached property for the widgets associated with a context.
     */
    Private.widgetsProperty = new properties_1.AttachedProperty({
        name: 'widgets',
        create: function () {
            return new vector_1.Vector();
        }
    });
})(Private || (Private = {}));
//# sourceMappingURL=widgetmanager.js.map