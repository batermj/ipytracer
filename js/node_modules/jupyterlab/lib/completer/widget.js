// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var signaling_1 = require('phosphor/lib/core/signaling');
var query_1 = require('phosphor/lib/dom/query');
var widget_1 = require('phosphor/lib/ui/widget');
/**
 * The class name added to completer menu widgets.
 */
var COMPLETER_CLASS = 'jp-Completer';
/**
 * The class name added to completer menu items.
 */
var ITEM_CLASS = 'jp-Completer-item';
/**
 * The class name added to an active completer menu item.
 */
var ACTIVE_CLASS = 'jp-mod-active';
/**
 * The class name added to a completer widget that is scrolled out of view.
 */
var OUTOFVIEW_CLASS = 'jp-mod-outofview';
/**
 * The minimum height of a completer widget.
 */
var MIN_HEIGHT = 20;
/**
 * The maximum height of a completer widget.
 *
 * #### Notes
 * This value is only used if a CSS max-height attribute is not set for the
 * completer. It is a fallback value.
 */
var MAX_HEIGHT = 200;
/**
 * A flag to indicate that event handlers are caught in the capture phase.
 */
var USE_CAPTURE = true;
/**
 * A widget that enables text completion.
 */
var CompleterWidget = (function (_super) {
    __extends(CompleterWidget, _super);
    /**
     * Construct a text completer menu widget.
     */
    function CompleterWidget(options) {
        if (options === void 0) { options = {}; }
        _super.call(this, { node: document.createElement('ul') });
        this._anchor = null;
        this._anchorPoint = 0;
        this._activeIndex = 0;
        this._model = null;
        this._renderer = null;
        this._renderer = options.renderer || CompleterWidget.defaultRenderer;
        this.anchor = options.anchor || null;
        this.model = options.model || null;
        this.addClass(COMPLETER_CLASS);
        // Completer widgets are hidden until they are populated.
        this.hide();
    }
    Object.defineProperty(CompleterWidget.prototype, "model", {
        /**
         * The model used by the completer widget.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._model;
        },
        set: function (model) {
            if (!model && !this._model || model === this._model) {
                return;
            }
            if (this._model) {
                this._model.stateChanged.disconnect(this.onModelStateChanged, this);
            }
            this._model = model;
            if (this._model) {
                this._model.stateChanged.connect(this.onModelStateChanged, this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompleterWidget.prototype, "anchor", {
        /**
         * The semantic parent of the completer widget, its anchor element. An
         * event listener will peg the position of the completer widget to the
         * anchor element's scroll position. Other event listeners will guarantee
         * the completer widget behaves like a child of the reference element even
         * if it does not appear as a descendant in the DOM.
         */
        get: function () {
            return this._anchor;
        },
        set: function (element) {
            if (this._anchor === element) {
                return;
            }
            // Clean up scroll listener if anchor is being replaced.
            if (this._anchor) {
                this._anchor.removeEventListener('scroll', this, USE_CAPTURE);
            }
            this._anchor = element;
            // Add scroll listener to anchor element.
            if (this._anchor) {
                this._anchor.addEventListener('scroll', this, USE_CAPTURE);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the completer widget.
     */
    CompleterWidget.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._model = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Reset the widget.
     */
    CompleterWidget.prototype.reset = function () {
        this._reset();
        if (this._model) {
            this._model.reset();
        }
    };
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    CompleterWidget.prototype.handleEvent = function (event) {
        if (this.isHidden || !this._anchor) {
            return;
        }
        switch (event.type) {
            case 'keydown':
                this._evtKeydown(event);
                break;
            case 'mousedown':
                this._evtMousedown(event);
                break;
            case 'scroll':
                this._evtScroll(event);
                break;
            default:
                break;
        }
    };
    /**
     * Handle `after-attach` messages for the widget.
     */
    CompleterWidget.prototype.onAfterAttach = function (msg) {
        document.addEventListener('keydown', this, USE_CAPTURE);
        document.addEventListener('mousedown', this, USE_CAPTURE);
    };
    /**
     * Handle `before_detach` messages for the widget.
     */
    CompleterWidget.prototype.onBeforeDetach = function (msg) {
        document.removeEventListener('keydown', this, USE_CAPTURE);
        document.removeEventListener('mousedown', this, USE_CAPTURE);
        if (this._anchor) {
            this._anchor.removeEventListener('scroll', this, USE_CAPTURE);
        }
    };
    /**
     * Handle model state changes.
     */
    CompleterWidget.prototype.onModelStateChanged = function () {
        if (this.isAttached) {
            this.update();
        }
    };
    /**
     * Handle `update-request` messages.
     */
    CompleterWidget.prototype.onUpdateRequest = function (msg) {
        var model = this._model;
        var anchor = this._anchor;
        if (!model || !anchor) {
            return;
        }
        var items = model.items;
        // If there are no items, reset and bail.
        if (!items || !items.length) {
            this._reset();
            if (!this.isHidden) {
                this.hide();
                this.visibilityChanged.emit(void 0);
            }
            return;
        }
        // If there is only one item, signal and bail.
        if (items.length === 1) {
            this.selected.emit(items[0].raw);
            this.reset();
            return;
        }
        // Clear the node.
        var node = this.node;
        node.textContent = '';
        // Populate the completer items.
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var item = items_1[_i];
            var li = this._renderer.createItemNode(item);
            // Set the raw, un-marked up value as a data attribute.
            li.setAttribute('data-value', item.raw);
            node.appendChild(li);
        }
        var active = node.querySelectorAll("." + ITEM_CLASS)[this._activeIndex];
        active.classList.add(ACTIVE_CLASS);
        if (this.isHidden) {
            this.show();
            this.visibilityChanged.emit(void 0);
        }
        this._anchorPoint = anchor.scrollTop;
        this._setGeometry();
        // If this is the first time the current completer session has loaded,
        // populate any initial subset match.
        if (this._model.subsetMatch) {
            this._populateSubset();
            this.model.subsetMatch = false;
        }
    };
    /**
     * Cycle through the available completer items.
     */
    CompleterWidget.prototype._cycle = function (direction) {
        var items = this.node.querySelectorAll("." + ITEM_CLASS);
        var index = this._activeIndex;
        var active = this.node.querySelector("." + ACTIVE_CLASS);
        active.classList.remove(ACTIVE_CLASS);
        if (direction === 'up') {
            this._activeIndex = index === 0 ? items.length - 1 : index - 1;
        }
        else {
            this._activeIndex = index < items.length - 1 ? index + 1 : 0;
        }
        active = items[this._activeIndex];
        active.classList.add(ACTIVE_CLASS);
        query_1.scrollIntoViewIfNeeded(this.node, active);
    };
    /**
     * Handle keydown events for the widget.
     */
    CompleterWidget.prototype._evtKeydown = function (event) {
        if (this.isHidden || !this._anchor) {
            return;
        }
        var target = event.target;
        while (target !== document.documentElement) {
            if (target === this._anchor) {
                switch (event.keyCode) {
                    case 9:
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        this._model.subsetMatch = true;
                        var populated = this._populateSubset();
                        this.model.subsetMatch = false;
                        if (populated) {
                            return;
                        }
                        this._selectActive();
                        return;
                    case 13:
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        this._selectActive();
                        return;
                    case 27:
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        this.reset();
                        return;
                    case 38: // Up arrow key
                    case 40:
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        this._cycle(event.keyCode === 38 ? 'up' : 'down');
                        return;
                    default:
                        return;
                }
            }
            target = target.parentElement;
        }
        this.reset();
    };
    /**
     * Handle mousedown events for the widget.
     */
    CompleterWidget.prototype._evtMousedown = function (event) {
        if (this.isHidden || !this._anchor) {
            return;
        }
        if (Private.nonstandardClick(event)) {
            this.reset();
            return;
        }
        var target = event.target;
        while (target !== document.documentElement) {
            // If the user has made a selection, emit its value and reset the widget.
            if (target.classList.contains(ITEM_CLASS)) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
                this.selected.emit(target.getAttribute('data-value'));
                this.reset();
                return;
            }
            // If the mouse event happened anywhere else in the widget, bail.
            if (target === this.node) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
                return;
            }
            target = target.parentElement;
        }
        this.reset();
    };
    /**
     * Handle scroll events for the widget
     */
    CompleterWidget.prototype._evtScroll = function (event) {
        if (this.isHidden || !this._anchor) {
            return;
        }
        this._setGeometry();
    };
    /**
     * Populate the completer up to the longest initial subset of items.
     *
     * @returns `true` if a subset match was found and populated.
     */
    CompleterWidget.prototype._populateSubset = function () {
        var items = this.node.querySelectorAll("." + ITEM_CLASS);
        var subset = Private.commonSubset(Private.itemValues(items));
        var query = this.model.query;
        if (subset && subset !== query && subset.indexOf(query) === 0) {
            this.model.query = subset;
            this.selected.emit(subset);
            this.update();
            return true;
        }
        return false;
    };
    /**
     * Reset the internal flags to defaults.
     */
    CompleterWidget.prototype._reset = function () {
        this._activeIndex = 0;
        this._anchorPoint = 0;
    };
    /**
     * Set the visible dimensions of the widget.
     */
    CompleterWidget.prototype._setGeometry = function () {
        var node = this.node;
        var model = this._model;
        // This is an overly defensive test: `cursor` will always exist if
        // `original` exists, except in contrived tests. But since it is possible
        // to generate a runtime error, the check occurs here.
        if (!model || !model.original || !model.cursor) {
            return;
        }
        // Clear any previously set max-height.
        node.style.maxHeight = '';
        // Clear any programmatically set margin-top.
        node.style.marginTop = '';
        // Make sure the node is visible.
        node.classList.remove(OUTOFVIEW_CLASS);
        // Always use the original coordinates to calculate completer position.
        var _a = model.original, coords = _a.coords, chWidth = _a.chWidth, chHeight = _a.chHeight;
        var style = window.getComputedStyle(node);
        var innerHeight = window.innerHeight;
        var scrollDelta = this._anchorPoint - this._anchor.scrollTop;
        var spaceAbove = coords.top + scrollDelta;
        var spaceBelow = innerHeight - coords.bottom - scrollDelta;
        var marginTop = parseInt(style.marginTop, 10) || 0;
        var maxHeight = parseInt(style.maxHeight, 10) || MAX_HEIGHT;
        var minHeight = parseInt(style.minHeight, 10) || MIN_HEIGHT;
        var anchorRect = this._anchor.getBoundingClientRect();
        var top;
        // If the whole completer fits below or if there is more space below, then
        // rendering the completer below the text being typed is privileged so that
        // the code above is not obscured.
        var renderBelow = spaceBelow >= maxHeight || spaceBelow >= spaceAbove;
        if (renderBelow) {
            maxHeight = Math.min(spaceBelow - marginTop, maxHeight);
        }
        else {
            maxHeight = Math.min(spaceAbove, maxHeight);
            // If the completer renders above the text, its top margin is irrelevant.
            node.style.marginTop = '0px';
        }
        node.style.maxHeight = maxHeight + "px";
        // Make sure the completer ought to be visible.
        var withinBounds = maxHeight > minHeight &&
            spaceBelow >= chHeight &&
            spaceAbove >= anchorRect.top;
        if (!withinBounds) {
            node.classList.add(OUTOFVIEW_CLASS);
            return;
        }
        var borderLeftWidth = style.borderLeftWidth;
        var left = coords.left + (parseInt(borderLeftWidth, 10) || 0);
        var _b = this._model.cursor, start = _b.start, end = _b.end;
        var nodeRect = node.getBoundingClientRect();
        // Position the completer vertically.
        top = renderBelow ? innerHeight - spaceBelow : spaceAbove - nodeRect.height;
        node.style.top = Math.floor(top) + "px";
        // Move completer to the start of the blob being completed.
        left -= chWidth * (end - start);
        node.style.left = Math.ceil(left) + "px";
        node.style.width = 'auto';
        // Expand the menu width by the scrollbar size, if present.
        if (node.scrollHeight >= maxHeight) {
            node.style.width = (2 * node.offsetWidth - node.clientWidth) + "px";
            node.scrollTop = 0;
        }
    };
    /**
     * Emit the selected signal for the current active item and reset.
     */
    CompleterWidget.prototype._selectActive = function () {
        var active = this.node.querySelector("." + ACTIVE_CLASS);
        if (!active) {
            this._reset();
            return;
        }
        this.selected.emit(active.getAttribute('data-value'));
        this.reset();
    };
    return CompleterWidget;
}(widget_1.Widget));
exports.CompleterWidget = CompleterWidget;
// Define the signals for the `CompleterWidget` class.
signaling_1.defineSignal(CompleterWidget.prototype, 'selected');
signaling_1.defineSignal(CompleterWidget.prototype, 'visibilityChanged');
var CompleterWidget;
(function (CompleterWidget) {
    /**
     * The default implementation of an `IRenderer`.
     */
    var Renderer = (function () {
        function Renderer() {
        }
        /**
         * Create an item node for a text completer menu.
         */
        Renderer.prototype.createItemNode = function (item) {
            var li = document.createElement('li');
            var code = document.createElement('code');
            // Use innerHTML because search results include <mark> tags.
            code.innerHTML = item.text;
            li.className = ITEM_CLASS;
            li.appendChild(code);
            return li;
        };
        return Renderer;
    }());
    CompleterWidget.Renderer = Renderer;
    /**
     * The default `IRenderer` instance.
     */
    CompleterWidget.defaultRenderer = new Renderer();
})(CompleterWidget = exports.CompleterWidget || (exports.CompleterWidget = {}));
/**
 * A namespace for completer widget private data.
 */
var Private;
(function (Private) {
    /**
     * Returns the common subset string that a list of strings shares.
     */
    function commonSubset(values) {
        var len = values.length;
        var subset = '';
        if (len < 2) {
            return subset;
        }
        var strlen = values[0].length;
        for (var i = 0; i < strlen; i++) {
            var ch = values[0][i];
            for (var j = 1; j < len; j++) {
                if (values[j][i] !== ch) {
                    return subset;
                }
            }
            subset += ch;
        }
        return subset;
    }
    Private.commonSubset = commonSubset;
    /**
     * Returns the list of raw item values currently in the DOM.
     */
    function itemValues(items) {
        var values = [];
        for (var i = 0, len = items.length; i < len; i++) {
            values.push(items[i].getAttribute('data-value'));
        }
        return values;
    }
    Private.itemValues = itemValues;
    /**
     * Returns true for any modified click event (i.e., not a left-click).
     */
    function nonstandardClick(event) {
        return event.button !== 0 ||
            event.altKey ||
            event.ctrlKey ||
            event.shiftKey ||
            event.metaKey;
    }
    Private.nonstandardClick = nonstandardClick;
})(Private || (Private = {}));
//# sourceMappingURL=widget.js.map