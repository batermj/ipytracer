// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
/**
 * A completion handler for cell widgets.
 */
var CellCompletionHandler = (function () {
    /**
     * Construct a new completion handler for a widget.
     */
    function CellCompletionHandler(completion) {
        this._activeCell = null;
        this._completion = null;
        this._kernel = null;
        this._pending = 0;
        this._completion = completion;
        this._completion.selected.connect(this.onCompletionSelected, this);
    }
    Object.defineProperty(CellCompletionHandler.prototype, "kernel", {
        /**
         * The kernel used by the completion handler.
         */
        get: function () {
            return this._kernel;
        },
        set: function (value) {
            this._kernel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CellCompletionHandler.prototype, "activeCell", {
        /**
         * The cell widget used by the completion handler.
         */
        get: function () {
            return this._activeCell;
        },
        set: function (newValue) {
            if (newValue === this._activeCell) {
                return;
            }
            if (this._activeCell && !this._activeCell.isDisposed) {
                var editor = this._activeCell.editor;
                editor.textChanged.disconnect(this.onTextChanged, this);
                editor.completionRequested.disconnect(this.onCompletionRequested, this);
            }
            this._activeCell = newValue;
            if (this._activeCell) {
                var editor = this._activeCell.editor;
                editor.textChanged.connect(this.onTextChanged, this);
                editor.completionRequested.connect(this.onCompletionRequested, this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CellCompletionHandler.prototype, "isDisposed", {
        /**
         * Get whether the completion handler is disposed.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._completion === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources used by the handler.
     */
    CellCompletionHandler.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._completion = null;
        this._kernel = null;
        this._activeCell = null;
    };
    /**
     * Make a completion request using the kernel.
     */
    CellCompletionHandler.prototype.makeRequest = function (request) {
        var _this = this;
        if (!this._kernel) {
            return Promise.reject(new Error('no kernel for completion request'));
        }
        var content = {
            code: request.currentValue,
            cursor_pos: request.position
        };
        var pending = ++this._pending;
        return this._kernel.complete(content).then(function (msg) {
            _this.onReply(pending, request, msg);
        });
    };
    /**
     * Receive a completion reply from the kernel.
     */
    CellCompletionHandler.prototype.onReply = function (pending, request, msg) {
        // If we have been disposed, bail.
        if (this.isDisposed) {
            return;
        }
        // If a newer completion request has created a pending request, bail.
        if (pending !== this._pending) {
            return;
        }
        var value = msg.content;
        var model = this._completion.model;
        // Completion request failures or negative results fail silently.
        if (value.status !== 'ok') {
            model.reset();
            return;
        }
        // Update the original request.
        model.original = request;
        // Update the options.
        model.options = value.matches;
        // Update the cursor.
        model.cursor = { start: value.cursor_start, end: value.cursor_end };
    };
    /**
     * Handle a text changed signal from an editor.
     */
    CellCompletionHandler.prototype.onTextChanged = function (editor, change) {
        if (!this._completion.model) {
            return;
        }
        this._completion.model.handleTextChange(change);
    };
    /**
     * Handle a completion requested signal from an editor.
     */
    CellCompletionHandler.prototype.onCompletionRequested = function (editor, request) {
        if (!this.kernel || !this._completion.model) {
            return;
        }
        this.makeRequest(request);
    };
    /**
     * Handle a completion selected signal from the completion widget.
     */
    CellCompletionHandler.prototype.onCompletionSelected = function (widget, value) {
        if (!this._activeCell || !this._completion.model) {
            return;
        }
        var patch = this._completion.model.createPatch(value);
        if (!patch) {
            return;
        }
        var cell = this._activeCell;
        cell.model.source = patch.text;
        cell.editor.setCursorPosition(patch.position);
    };
    return CellCompletionHandler;
}());
exports.CellCompletionHandler = CellCompletionHandler;
