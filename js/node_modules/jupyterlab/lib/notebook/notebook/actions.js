// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var searching_1 = require('phosphor/lib/algorithm/searching');
var cells_1 = require('../cells');
var widget_1 = require('./widget');
/**
 * A namespace for handling actions on a notebook.
 *
 * #### Notes
 * All of the actions are a no-op if there is no model on the notebook.
 * The actions set the widget `mode` to `'command'` unless otherwise specified.
 * The actions will preserve the selection on the notebook widget unless
 * otherwise specified.
 */
var NotebookActions;
(function (NotebookActions) {
    /**
     * Split the active cell into two cells.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * It will preserve the existing mode.
     * The second cell will be activated.
     * The existing selection will be cleared.
     * The leading whitespace in the second cell will be removed.
     * If there is no content, two empty cells will be created.
     * Both cells will have the same type as the original cell.
     * This action can be undone.
     */
    function splitCell(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        widget.deselectAll();
        var nbModel = widget.model;
        var index = widget.activeCellIndex;
        var child = widget.widgets.at(index);
        var position = child.editor.getCursorPosition();
        var orig = child.model.source;
        // Create new models to preserve history.
        var clone0 = Private.cloneCell(nbModel, child.model);
        var clone1 = Private.cloneCell(nbModel, child.model);
        if (clone0.type === 'code') {
            clone0.outputs.clear();
        }
        clone0.source = orig.slice(0, position);
        clone1.source = orig.slice(position).replace(/^\s+/g, '');
        // Make the changes while preserving history.
        var cells = nbModel.cells;
        cells.beginCompoundOperation();
        cells.set(index, clone0);
        cells.insert(index + 1, clone1);
        cells.endCompoundOperation();
        widget.activeCellIndex++;
        widget.scrollToActiveCell();
        widget.activate();
    }
    NotebookActions.splitCell = splitCell;
    /**
     * Merge the selected cells.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * The widget mode will be preserved.
     * If only one cell is selected, the next cell will be selected.
     * If the active cell is a code cell, its outputs will be cleared.
     * This action can be undone.
     * The final cell will have the same type as the active cell.
     * If the active cell is a markdown cell, it will be unrendered.
     */
    function mergeCells(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        var toMerge = [];
        var toDelete = [];
        var model = widget.model;
        var cells = model.cells;
        var primary = widget.activeCell;
        var index = widget.activeCellIndex;
        // Get the cells to merge.
        iteration_1.each(iteration_1.enumerate(widget.widgets), function (_a) {
            var i = _a[0], child = _a[1];
            if (widget.isSelected(child)) {
                toMerge.push(child.model.source);
                if (i !== index) {
                    toDelete.push(child.model);
                }
            }
        });
        // Check for only a single cell selected.
        if (toMerge.length === 1) {
            // Bail if it is the last cell.
            if (index === cells.length - 1) {
                return;
            }
            // Otherwise merge with the next cell.
            var cellModel = cells.at(index + 1);
            toMerge.push(cellModel.source);
            toDelete.push(cellModel);
        }
        widget.deselectAll();
        // Create a new cell for the source to preserve history.
        var newModel = Private.cloneCell(model, primary.model);
        newModel.source = toMerge.join('\n\n');
        if (newModel instanceof cells_1.CodeCellModel) {
            newModel.outputs.clear();
        }
        // Make the changes while preserving history.
        cells.beginCompoundOperation();
        cells.set(index, newModel);
        iteration_1.each(toDelete, function (cell) {
            cells.remove(cell);
        });
        cells.endCompoundOperation();
        // If the original cell is a markdown cell, make sure
        // the new cell is unrendered.
        if (primary instanceof cells_1.MarkdownCellWidget) {
            var cell = widget.activeCell;
            cell.rendered = false;
        }
    }
    NotebookActions.mergeCells = mergeCells;
    /**
     * Delete the selected cells.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * The cell after the last selected cell will be activated.
     * It will add a code cell if all cells are deleted.
     * This action can be undone.
     */
    function deleteCells(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        var model = widget.model;
        var cells = model.cells;
        var toDelete = [];
        var index = -1;
        widget.mode = 'command';
        // Find the cells to delete.
        iteration_1.each(iteration_1.enumerate(widget.widgets), function (_a) {
            var i = _a[0], child = _a[1];
            if (widget.isSelected(child)) {
                index = i;
                toDelete.push(cells.at(i));
            }
        });
        // Delete the cells as one undo event.
        cells.beginCompoundOperation();
        iteration_1.each(toDelete, function (cell) {
            cells.remove(cell);
        });
        // The model will add a new code cell if there are no
        // remaining cells.
        model.cells.endCompoundOperation();
        // Select the cell *after* the last selected.
        // Note: The activeCellIndex is clamped to the available cells,
        // so if the last cell is deleted the previous cell will be activated.
        index -= toDelete.length - 1;
        widget.activeCellIndex = index;
    }
    NotebookActions.deleteCells = deleteCells;
    /**
     * Insert a new code cell above the active cell.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * The widget mode will be preserved.
     * This action can be undone.
     * The existing selection will be cleared.
     * The new cell will the active cell.
     */
    function insertAbove(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        var cell = widget.model.factory.createCodeCell();
        widget.model.cells.insert(widget.activeCellIndex, cell);
        widget.deselectAll();
    }
    NotebookActions.insertAbove = insertAbove;
    /**
     * Insert a new code cell below the active cell.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * The widget mode will be preserved.
     * This action can be undone.
     * The existing selection will be cleared.
     * The new cell will be the active cell.
     */
    function insertBelow(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        var cell = widget.model.factory.createCodeCell();
        widget.model.cells.insert(widget.activeCellIndex + 1, cell);
        widget.activeCellIndex++;
        widget.deselectAll();
    }
    NotebookActions.insertBelow = insertBelow;
    /**
     * Move the selected cell(s) down.
     *
     * @param widget = The target notebook widget.
     */
    function moveDown(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        var cells = widget.model.cells;
        var widgets = widget.widgets;
        cells.beginCompoundOperation();
        for (var i = cells.length - 2; i > -1; i--) {
            if (widget.isSelected(widgets.at(i))) {
                if (!widget.isSelected(widgets.at(i + 1))) {
                    cells.move(i, i + 1);
                    if (widget.activeCellIndex === i) {
                        widget.activeCellIndex++;
                    }
                    widget.select(widgets.at(i + 1));
                    widget.deselect(widgets.at(i));
                }
            }
        }
        cells.endCompoundOperation();
    }
    NotebookActions.moveDown = moveDown;
    /**
     * Move the selected cell(s) up.
     *
     * @param widget - The target notebook widget.
     */
    function moveUp(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        var cells = widget.model.cells;
        var widgets = widget.widgets;
        cells.beginCompoundOperation();
        for (var i = 1; i < cells.length; i++) {
            if (widget.isSelected(widgets.at(i))) {
                if (!widget.isSelected(widgets.at(i - 1))) {
                    cells.move(i, i - 1);
                    if (widget.activeCellIndex === i) {
                        widget.activeCellIndex--;
                    }
                    widget.select(widgets.at(i - 1));
                    widget.deselect(widgets.at(i));
                }
            }
        }
        cells.endCompoundOperation();
    }
    NotebookActions.moveUp = moveUp;
    /**
     * Change the selected cell type(s).
     *
     * @param widget - The target notebook widget.
     *
     * @param value - The target cell type.
     *
     * #### Notes
     * It should preserve the widget mode.
     * This action can be undone.
     * The existing selection will be cleared.
     * Any cells converted to markdown will be unrendered.
     */
    function changeCellType(widget, value) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        var model = widget.model;
        var cells = model.cells;
        cells.beginCompoundOperation();
        iteration_1.each(iteration_1.enumerate(widget.widgets), function (_a) {
            var i = _a[0], child = _a[1];
            if (!widget.isSelected(child)) {
                return;
            }
            if (child.model.type !== value) {
                var newCell = void 0;
                switch (value) {
                    case 'code':
                        newCell = model.factory.createCodeCell(child.model.toJSON());
                        break;
                    case 'markdown':
                        newCell = model.factory.createMarkdownCell(child.model.toJSON());
                        break;
                    default:
                        newCell = model.factory.createRawCell(child.model.toJSON());
                }
                cells.set(i, newCell);
            }
            if (value === 'markdown') {
                // Fetch the new widget and unrender it.
                child = widget.widgets.at(i);
                child.rendered = false;
            }
        });
        cells.endCompoundOperation();
        widget.deselectAll();
    }
    NotebookActions.changeCellType = changeCellType;
    /**
     * Run the selected cell(s).
     *
     * @param widget - The target notebook widget.
     *
     * @param kernel - An optional kernel object.
     *
     * #### Notes
     * The last selected cell will be activated.
     * The existing selection will be cleared.
     * An execution error will prevent the remaining code cells from executing.
     * All markdown cells will be rendered.
     */
    function run(widget, kernel) {
        if (!widget.model || !widget.activeCell) {
            return Promise.resolve(false);
        }
        widget.mode = 'command';
        var selected = [];
        var lastIndex = widget.activeCellIndex;
        var i = 0;
        iteration_1.each(widget.widgets, function (child) {
            if (widget.isSelected(child)) {
                selected.push(child);
                lastIndex = i;
            }
            i++;
        });
        widget.activeCellIndex = lastIndex;
        widget.deselectAll();
        var promises = [];
        iteration_1.each(selected, function (child) {
            promises.push(Private.runCell(widget, child, kernel));
        });
        return Promise.all(promises).then(function (results) {
            // Post an update request.
            widget.update();
            for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
                var result = results_1[_i];
                if (!result) {
                    return false;
                }
            }
            return true;
        });
    }
    NotebookActions.run = run;
    /**
     * Run the selected cell(s) and advance to the next cell.
     *
     * @param widget - The target notebook widget.
     *
     * @param kernel - An optional kernel object.
     *
     * #### Notes
     * The existing selection will be cleared.
     * The cell after the last selected cell will be activated.
     * An execution error will prevent the remaining code cells from executing.
     * All markdown cells will be rendered.
     * If the last selected cell is the last cell, a new code cell
     * will be created in `'edit'` mode.  The new cell creation can be undone.
     */
    function runAndAdvance(widget, kernel) {
        if (!widget.model || !widget.activeCell) {
            return Promise.resolve(false);
        }
        var promise = run(widget, kernel);
        var model = widget.model;
        if (widget.activeCellIndex === widget.widgets.length - 1) {
            var cell = model.factory.createCodeCell();
            model.cells.pushBack(cell);
            widget.activeCellIndex++;
            widget.mode = 'edit';
        }
        else {
            widget.activeCellIndex++;
        }
        widget.scrollToActiveCell();
        return promise;
    }
    NotebookActions.runAndAdvance = runAndAdvance;
    /**
     * Run the selected cell(s) and insert a new code cell.
     *
     * @param widget - The target notebook widget.
     *
     * @param kernel - An optional kernel object.
     *
     * #### Notes
     * An execution error will prevent the remaining code cells from executing.
     * All markdown cells will be rendered.
     * The widget mode will be set to `'edit'` after running.
     * The existing selection will be cleared.
     * The cell insert can be undone.
     */
    function runAndInsert(widget, kernel) {
        if (!widget.model || !widget.activeCell) {
            return Promise.resolve(false);
        }
        var promise = run(widget, kernel);
        var model = widget.model;
        var cell = model.factory.createCodeCell();
        model.cells.insert(widget.activeCellIndex + 1, cell);
        widget.activeCellIndex++;
        widget.scrollToActiveCell();
        widget.mode = 'edit';
        return promise;
    }
    NotebookActions.runAndInsert = runAndInsert;
    /**
     * Run all of the cells in the notebook.
     *
     * @param widget - The target notebook widget.
     *
     * @param kernel - An optional kernel object.
     * #### Notes
     * The existing selection will be cleared.
     * An execution error will prevent the remaining code cells from executing.
     * All markdown cells will be rendered.
     * The last cell in the notebook will be activated.
     */
    function runAll(widget, kernel) {
        if (!widget.model || !widget.activeCell) {
            return Promise.resolve(false);
        }
        iteration_1.each(widget.widgets, function (child) {
            widget.select(child);
        });
        return run(widget, kernel);
    }
    NotebookActions.runAll = runAll;
    /**
     * Select the above the active cell.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * The widget mode will be preserved.
     * This is a no-op if the first cell is the active cell.
     * The existing selection will be cleared.
     */
    function selectAbove(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        if (widget.activeCellIndex === 0) {
            return;
        }
        widget.activeCellIndex -= 1;
        widget.scrollToActiveCell();
        widget.deselectAll();
    }
    NotebookActions.selectAbove = selectAbove;
    /**
     * Select the cell below the active cell.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * The widget mode will be preserved.
     * This is a no-op if the last cell is the active cell.
     * The existing selection will be cleared.
     */
    function selectBelow(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        if (widget.activeCellIndex === widget.widgets.length - 1) {
            return;
        }
        widget.activeCellIndex += 1;
        widget.scrollToActiveCell();
        widget.deselectAll();
    }
    NotebookActions.selectBelow = selectBelow;
    /**
     * Extend the selection to the cell above.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * This is a no-op if the first cell is the active cell.
     * The new cell will be activated.
     */
    function extendSelectionAbove(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        // Do not wrap around.
        if (widget.activeCellIndex === 0) {
            return;
        }
        widget.mode = 'command';
        var current = widget.activeCell;
        var prev = widget.widgets.at(widget.activeCellIndex - 1);
        if (widget.isSelected(prev)) {
            widget.deselect(current);
            if (widget.activeCellIndex > 1) {
                var prevPrev = widget.widgets.at(widget.activeCellIndex - 2);
                if (!widget.isSelected(prevPrev)) {
                    widget.deselect(prev);
                }
            }
        }
        else {
            widget.select(current);
        }
        widget.activeCellIndex -= 1;
        widget.scrollToActiveCell();
    }
    NotebookActions.extendSelectionAbove = extendSelectionAbove;
    /**
     * Extend the selection to the cell below.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * This is a no-op if the last cell is the active cell.
     * The new cell will be activated.
     */
    function extendSelectionBelow(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        // Do not wrap around.
        if (widget.activeCellIndex === widget.widgets.length - 1) {
            return;
        }
        widget.mode = 'command';
        var current = widget.activeCell;
        var next = widget.widgets.at(widget.activeCellIndex + 1);
        if (widget.isSelected(next)) {
            widget.deselect(current);
            if (widget.activeCellIndex < widget.model.cells.length - 2) {
                var nextNext = widget.widgets.at(widget.activeCellIndex + 2);
                if (!widget.isSelected(nextNext)) {
                    widget.deselect(next);
                }
            }
        }
        else {
            widget.select(current);
        }
        widget.activeCellIndex += 1;
        widget.scrollToActiveCell();
    }
    NotebookActions.extendSelectionBelow = extendSelectionBelow;
    /**
     * Copy the selected cell data to a clipboard.
     *
     * @param widget - The target notebook widget.
     *
     * @param clipboard - The clipboard object.
     */
    function copy(widget, clipboard) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        widget.mode = 'command';
        clipboard.clear();
        var data = [];
        iteration_1.each(widget.widgets, function (child) {
            if (widget.isSelected(child)) {
                data.push(child.model.toJSON());
            }
        });
        clipboard.setData(widget_1.JUPYTER_CELL_MIME, data);
        widget.deselectAll();
    }
    NotebookActions.copy = copy;
    /**
     * Cut the selected cell data to a clipboard.
     *
     * @param widget - The target notebook widget.
     *
     * @param clipboard - The clipboard object.
     *
     * #### Notes
     * This action can be undone.
     * A new code cell is added if all cells are cut.
     */
    function cut(widget, clipboard) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        var data = [];
        var model = widget.model;
        var cells = model.cells;
        var toDelete = [];
        widget.mode = 'command';
        // Gather the cell data.
        iteration_1.each(widget.widgets, function (child) {
            if (widget.isSelected(child)) {
                data.push(child.model.toJSON());
                toDelete.push(child.model);
            }
        });
        // Preserve the history as one undo event.
        model.cells.beginCompoundOperation();
        iteration_1.each(toDelete, function (cell) {
            cells.remove(cell);
        });
        // If there are no cells, add a code cell.
        if (!model.cells.length) {
            var cell = model.factory.createCodeCell();
            model.cells.pushBack(cell);
        }
        model.cells.endCompoundOperation();
        clipboard.setData(widget_1.JUPYTER_CELL_MIME, data);
    }
    NotebookActions.cut = cut;
    /**
     * Paste cells from a clipboard.
     *
     * @param widget - The target notebook widget.
     *
     * @param clipboard - The clipboard object.
     *
     * #### Notes
     * The cells are pasted below the active cell.
     * The last pasted cell becomes the active cell.
     * This is a no-op if there is no cell data on the clipboard.
     * This action can be undone.
     */
    function paste(widget, clipboard) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        if (!clipboard.hasData(widget_1.JUPYTER_CELL_MIME)) {
            return;
        }
        var values = clipboard.getData(widget_1.JUPYTER_CELL_MIME);
        var model = widget.model;
        var newCells = [];
        widget.mode = 'command';
        iteration_1.each(values, function (value) {
            switch (value.cell_type) {
                case 'code':
                    newCells.push(model.factory.createCodeCell(value));
                    break;
                case 'markdown':
                    newCells.push(model.factory.createMarkdownCell(value));
                    break;
                default:
                    newCells.push(model.factory.createRawCell(value));
                    break;
            }
        });
        var index = widget.activeCellIndex;
        var cells = widget.model.cells;
        cells.beginCompoundOperation();
        iteration_1.each(newCells, function (cell) {
            cells.insert(++index, cell);
        });
        cells.endCompoundOperation();
        widget.activeCellIndex += newCells.length;
        widget.deselectAll();
    }
    NotebookActions.paste = paste;
    /**
     * Undo a cell action.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * This is a no-op if if there are no cell actions to undo.
     */
    function undo(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        widget.mode = 'command';
        widget.model.cells.undo();
        widget.deselectAll();
    }
    NotebookActions.undo = undo;
    /**
     * Redo a cell action.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * This is a no-op if there are no cell actions to redo.
     */
    function redo(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        widget.mode = 'command';
        widget.model.cells.redo();
        widget.deselectAll();
    }
    NotebookActions.redo = redo;
    /**
     * Toggle line numbers on the selected cell(s).
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * The original state is based on the state of the active cell.
     * The `mode` of the widget will be preserved.
     */
    function toggleLineNumbers(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        var lineNumbers = widget.activeCell.editor.lineNumbers;
        iteration_1.each(widget.widgets, function (child) {
            if (widget.isSelected(child)) {
                child.editor.lineNumbers = !lineNumbers;
            }
        });
    }
    NotebookActions.toggleLineNumbers = toggleLineNumbers;
    /**
     * Toggle the line number of all cells.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * The original state is based on the state of the active cell.
     * The `mode` of the widget will be preserved.
     */
    function toggleAllLineNumbers(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        var lineNumbers = widget.activeCell.editor.lineNumbers;
        iteration_1.each(widget.widgets, function (child) {
            child.editor.lineNumbers = !lineNumbers;
        });
    }
    NotebookActions.toggleAllLineNumbers = toggleAllLineNumbers;
    /**
     * Clear the code outputs of the selected cells.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * The widget `mode` will be preserved.
     */
    function clearOutputs(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        var cells = widget.model.cells;
        var i = 0;
        iteration_1.each(cells, function (cell) {
            var child = widget.widgets.at(i);
            if (widget.isSelected(child) && cell.type === 'code') {
                cell.outputs.clear();
                cell.executionCount = null;
            }
            i++;
        });
    }
    NotebookActions.clearOutputs = clearOutputs;
    /**
     * Clear all the code outputs on the widget.
     *
     * @param widget - The target notebook widget.
     *
     * #### Notes
     * The widget `mode` will be preserved.
     */
    function clearAllOutputs(widget) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        iteration_1.each(widget.model.cells, function (cell) {
            if (cell.type === 'code') {
                cell.outputs.clear();
                cell.executionCount = null;
            }
        });
    }
    NotebookActions.clearAllOutputs = clearAllOutputs;
    /**
     * Set the markdown header level.
     *
     * @param widget - The target notebook widget.
     *
     * @param level - The header level.
     *
     * #### Notes
     * All selected cells will be switched to markdown.
     * The level will be clamped between 1 and 6.
     * If there is an existing header, it will be replaced.
     * There will always be one blank space after the header.
     * The cells will be unrendered.
     */
    function setMarkdownHeader(widget, level) {
        if (!widget.model || !widget.activeCell) {
            return;
        }
        level = Math.min(Math.max(level, 1), 6);
        var cells = widget.model.cells;
        var i = 0;
        iteration_1.each(widget.widgets, function (child) {
            if (widget.isSelected(child)) {
                Private.setMarkdownHeader(cells.at(i), level);
            }
            i++;
        });
        changeCellType(widget, 'markdown');
    }
    NotebookActions.setMarkdownHeader = setMarkdownHeader;
})(NotebookActions = exports.NotebookActions || (exports.NotebookActions = {}));
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * Clone a cell model.
     */
    function cloneCell(model, cell) {
        switch (cell.type) {
            case 'code':
                return model.factory.createCodeCell(cell.toJSON());
            case 'markdown':
                return model.factory.createMarkdownCell(cell.toJSON());
            default:
                return model.factory.createRawCell(cell.toJSON());
        }
    }
    Private.cloneCell = cloneCell;
    /**
     * Run a cell.
     */
    function runCell(parent, child, kernel) {
        switch (child.model.type) {
            case 'markdown':
                child.rendered = true;
                break;
            case 'code':
                if (kernel) {
                    return child.execute(kernel).then(function (reply) {
                        if (reply && reply.content.status === 'ok') {
                            var content = reply.content;
                            if (content.payload && content.payload.length) {
                                handlePayload(content, parent, child);
                            }
                        }
                        return reply ? reply.content.status === 'ok' : true;
                    });
                }
                child.model.executionCount = null;
                break;
            default:
                break;
        }
        return Promise.resolve(true);
    }
    Private.runCell = runCell;
    /**
     * Handle payloads from an execute reply.
     *
     * #### Notes
     * Payloads are deprecated and there are no official interfaces for them in
     * the kernel type definitions.
     * See [Payloads (DEPRECATED)](https://jupyter-client.readthedocs.io/en/latest/messaging.html#payloads-deprecated).
     */
    function handlePayload(content, parent, child) {
        var setNextInput = content.payload.filter(function (i) {
            return i.source === 'set_next_input';
        })[0];
        if (!setNextInput) {
            return;
        }
        var text = setNextInput.text;
        var replace = setNextInput.replace;
        if (replace) {
            child.model.source = text;
            return;
        }
        // Create a new code cell and add as the next cell.
        var cell = parent.model.factory.createCodeCell();
        cell.source = text;
        var cells = parent.model.cells;
        var i = searching_1.indexOf(cells, child.model);
        if (i === -1) {
            cells.pushBack(cell);
        }
        else {
            cells.insert(i + 1, cell);
        }
    }
    /**
     * Set the markdown header level of a cell.
     */
    function setMarkdownHeader(cell, level) {
        var source = cell.source;
        var newHeader = Array(level + 1).join('#') + ' ';
        // Remove existing header or leading white space.
        var regex = /^(#+\s*)|^(\s*)/;
        var matches = regex.exec(source);
        if (matches) {
            source = source.slice(matches[0].length);
        }
        cell.source = newHeader + source;
    }
    Private.setMarkdownHeader = setMarkdownHeader;
})(Private || (Private = {}));
//# sourceMappingURL=actions.js.map