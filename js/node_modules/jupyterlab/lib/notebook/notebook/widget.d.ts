import { nbformat } from '@jupyterlab/services';
import { ISequence } from 'phosphor/lib/algorithm/sequence';
import { Message } from 'phosphor/lib/core/messaging';
import { ISignal } from 'phosphor/lib/core/signaling';
import { Widget } from 'phosphor/lib/ui/widget';
import { IChangedArgs } from '../../common/interfaces';
import { InspectionHandler } from '../../inspector';
import { RenderMime } from '../../rendermime';
import { BaseCellWidget, CodeCellWidget, MarkdownCellWidget, RawCellWidget, ICodeCellModel, IMarkdownCellModel, IRawCellModel } from '../cells';
import { INotebookModel } from './model';
/**
 * The mimetype used for Jupyter cell data.
 */
export declare const JUPYTER_CELL_MIME: string;
/**
 * The interactivity modes for the notebook.
 */
export declare type NotebookMode = 'command' | 'edit';
/**
 * A widget which renders static non-interactive notebooks.
 *
 * #### Notes
 * The widget model must be set separately and can be changed
 * at any time.  Consumers of the widget must account for a
 * `null` model, and may want to listen to the `modelChanged`
 * signal.
 */
export declare class StaticNotebook extends Widget {
    /**
     * Construct a notebook widget.
     */
    constructor(options: StaticNotebook.IOptions);
    /**
     * A signal emitted when the model of the notebook changes.
     */
    modelChanged: ISignal<this, void>;
    /**
     * A signal emitted when the model content changes.
     *
     * #### Notes
     * This is a convenience signal that follows the current model.
     */
    modelContentChanged: ISignal<this, void>;
    /**
     * The model for the widget.
     */
    model: INotebookModel;
    /**
     * Get the rendermime instance used by the widget.
     */
    readonly rendermime: RenderMime;
    /**
     * Get the renderer used by the widget.
     */
    readonly renderer: StaticNotebook.IRenderer;
    /**
     * Get the mimetype for code cells.
     */
    readonly codeMimetype: string;
    /**
     * A read-only sequence of the widgets in the notebook.
     */
    readonly widgets: ISequence<BaseCellWidget>;
    /**
     * Dispose of the resources held by the widget.
     */
    dispose(): void;
    /**
     * Handle a new model.
     *
     * #### Notes
     * This method is called after the model change has been handled
     * internally and before the `modelChanged` signal is emitted.
     * The default implementation is a no-op.
     */
    protected onModelChanged(oldValue: INotebookModel, newValue: INotebookModel): void;
    /**
     * Handle changes to the notebook model content.
     *
     * #### Notes
     * The default implementation emits the `modelContentChanged` signal.
     */
    protected onModelContentChanged(model: INotebookModel, args: void): void;
    /**
     * Handle changes to the notebook model metadata.
     *
     * #### Notes
     * The default implementation updates the mimetypes of the code cells
     * when the `language_info` metadata changes.
     */
    protected onMetadataChanged(model: INotebookModel, args: IChangedArgs<any>): void;
    /**
     * Handle a cell being inserted.
     *
     * The default implementation is a no-op
     */
    protected onCellInserted(index: number, cell: BaseCellWidget): void;
    /**
     * Handle a cell being moved.
     *
     * The default implementation is a no-op
     */
    protected onCellMoved(fromIndex: number, toIndex: number): void;
    /**
     * Handle a cell being removed.
     *
     * The default implementation is a no-op
     */
    protected onCellRemoved(cell: BaseCellWidget): void;
    /**
     * Handle a new model on the widget.
     */
    private _onModelChanged(oldValue, newValue);
    /**
     * Handle a change cells event.
     */
    private _onCellsChanged(sender, args);
    /**
     * Create a cell widget and insert into the notebook.
     */
    private _insertCell(index, cell);
    /**
     * Move a cell widget.
     */
    private _moveCell(fromIndex, toIndex);
    /**
     * Remove a cell widget.
     */
    private _removeCell(index);
    /**
     * Update the cell widgets.
     */
    private _updateCells();
    /**
     * Update a cell widget.
     */
    private _updateCell(index);
    /**
     * Update the mimetype of the notebook.
     */
    private _updateMimetype();
    private _mimetype;
    private _model;
    private _rendermime;
    private _renderer;
}
/**
 * The namespace for the `StaticNotebook` class statics.
 */
export declare namespace StaticNotebook {
    /**
     * An options object for initializing a static notebook.
     */
    interface IOptions {
        /**
         * The rendermime instance used by the widget.
         */
        rendermime: RenderMime;
        /**
         * The language preference for the model.
         */
        languagePreference?: string;
        /**
         * A renderer for a notebook.
         *
         * The default is a shared renderer instance.
         */
        renderer: IRenderer;
    }
    /**
     * A factory for creating code cell widgets.
     */
    interface IRenderer {
        /**
         * Create a new code cell widget.
         */
        createCodeCell(model: ICodeCellModel, rendermime: RenderMime): CodeCellWidget;
        /**
         * Create a new markdown cell widget.
         */
        createMarkdownCell(model: IMarkdownCellModel, rendermime: RenderMime): MarkdownCellWidget;
        /**
         * Create a new raw cell widget.
         */
        createRawCell(model: IRawCellModel): RawCellWidget;
        /**
         * Update a cell widget.
         */
        updateCell(cell: BaseCellWidget): void;
        /**
         * Get the preferred mimetype given language info.
         */
        getCodeMimetype(info: nbformat.ILanguageInfoMetadata): string;
    }
    /**
     * The default implementation of an `IRenderer`.
     */
    abstract class Renderer implements IRenderer {
        /**
         * Create a new code cell widget.
         */
        abstract createCodeCell(model: ICodeCellModel, rendermime: RenderMime): CodeCellWidget;
        /**
         * Create a new markdown cell widget.
         */
        abstract createMarkdownCell(model: IMarkdownCellModel, rendermime: RenderMime): MarkdownCellWidget;
        /**
         * Create a new raw cell widget.
         */
        abstract createRawCell(model: IRawCellModel): RawCellWidget;
        /**
         * Update a cell widget.
         *
         * #### Notes
         * The base implementation is a no-op.
         */
        updateCell(cell: BaseCellWidget): void;
        /**
         * Get the preferred mimetype given language info.
         */
        abstract getCodeMimetype(info: nbformat.ILanguageInfoMetadata): string;
    }
}
/**
 * A notebook widget that supports interactivity.
 */
export declare class Notebook extends StaticNotebook {
    /**
     * Construct a notebook widget.
     */
    constructor(options: StaticNotebook.IOptions);
    /**
     * A signal emitted when the active cell changes.
     *
     * #### Notes
     * This can be due to the active index changing or the
     * cell at the active index changing.
     */
    activeCellChanged: ISignal<this, BaseCellWidget>;
    /**
     * A signal emitted when the state of the notebook changes.
     */
    stateChanged: ISignal<this, IChangedArgs<any>>;
    /**
     * A signal emitted when the selection state of the notebook changes.
     */
    selectionChanged: ISignal<this, void>;
    /**
     * Get the inspection handler used by the console.
     */
    readonly inspectionHandler: InspectionHandler;
    /**
     * The interactivity mode of the notebook.
     */
    mode: NotebookMode;
    /**
     * The active cell index of the notebook.
     *
     * #### Notes
     * The index will be clamped to the bounds of the notebook cells.
     */
    activeCellIndex: number;
    /**
     * Get the active cell widget.
     */
    readonly activeCell: BaseCellWidget;
    /**
     * Dispose of the resources held by the widget.
     */
    dispose(): void;
    /**
     * Select a cell widget.
     *
     * #### Notes
     * It is a no-op if the value does not change.
     * It will emit the `selectionChanged` signal.
     */
    select(widget: BaseCellWidget): void;
    /**
     * Deselect a cell widget.
     *
     * #### Notes
     * It is a no-op if the value does not change.
     * It will emit the `selectionChanged` signal.
     */
    deselect(widget: BaseCellWidget): void;
    /**
     * Whether a cell is selected or is the active cell.
     */
    isSelected(widget: BaseCellWidget): boolean;
    /**
     * Deselect all of the cells.
     */
    deselectAll(): void;
    /**
     * Scroll so that the active cell is visible.
     */
    scrollToActiveCell(): void;
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the notebook panel's node. It should
     * not be called directly by user code.
     */
    handleEvent(event: Event): void;
    /**
     * Handle `after-attach` messages for the widget.
     */
    protected onAfterAttach(msg: Message): void;
    /**
     * Handle `before_detach` messages for the widget.
     */
    protected onBeforeDetach(msg: Message): void;
    /**
     * Handle `'activate-request'` messages.
     */
    protected onActivateRequest(msg: Message): void;
    /**
     * Handle `update-request` messages sent to the widget.
     */
    protected onUpdateRequest(msg: Message): void;
    /**
     * Handle a cell being inserted.
     */
    protected onCellInserted(index: number, cell: BaseCellWidget): void;
    /**
     * Handle a cell being moved.
     */
    protected onCellMoved(fromIndex: number, toIndex: number): void;
    /**
     * Handle a cell being removed.
     */
    protected onCellRemoved(cell: BaseCellWidget): void;
    /**
     * Handle a new model.
     */
    protected onModelChanged(oldValue: INotebookModel, newValue: INotebookModel): void;
    /**
     * Handle edge request signals from cells.
     */
    private _onEdgeRequest(widget, location);
    private _ensureFocus();
    /**
     * Find the cell index containing the target html element.
     *
     * #### Notes
     * Returns -1 if the cell is not found.
     */
    private _findCell(node);
    /**
     * Handle `mousedown` events for the widget.
     */
    private _evtMouseDown(event);
    /**
     * Handle the `'mouseup'` event for the widget.
     */
    private _evtMouseup(event);
    /**
     * Handle the `'mousemove'` event for the widget.
     */
    private _evtMousemove(event);
    /**
     * Handle the `'p-dragenter'` event for the widget.
     */
    private _evtDragEnter(event);
    /**
     * Handle the `'p-dragleave'` event for the widget.
     */
    private _evtDragLeave(event);
    /**
     * Handle the `'p-dragover'` event for the widget.
     */
    private _evtDragOver(event);
    /**
     * Handle the `'p-drop'` event for the widget.
     */
    private _evtDrop(event);
    /**
     * Start a drag event.
     */
    private _startDrag(index, clientX, clientY);
    /**
     * Handle `focus` events for the widget.
     */
    private _evtFocus(event);
    /**
     * Handle `blur` events for the widget.
     */
    private _evtBlur(event);
    /**
     * Handle `dblclick` events for the widget.
     */
    private _evtDblClick(event);
    /**
     * Extend the selection to a given index.
     */
    private _extendSelectionTo(index);
    private _activeCellIndex;
    private _activeCell;
    private _inspectionHandler;
    private _mode;
    private _drag;
    private _dragData;
    private _scrollHandler;
}
/**
 * The namespace for the `Notebook` class statics.
 */
export declare namespace Notebook {
    /**
     * An options object for initializing a notebook.
     */
    interface IOptions extends StaticNotebook.IOptions {
    }
    /**
     * The default implementation of an `IRenderer`.
     */
    abstract class Renderer extends StaticNotebook.Renderer {
    }
}
