// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var properties_1 = require('phosphor/lib/core/properties');
var panel_1 = require('phosphor/lib/ui/panel');
var widget_1 = require('phosphor/lib/ui/widget');
/**
 * The class name added to notebook toolbars.
 */
var NB_TOOLBAR = 'jp-NBToolbar';
/**
 * The class name added to notebook toolbar items.
 */
var TOOLBAR_ITEM = 'jp-NBToolbar-item';
/**
 * The class name added to notebook toolbar buttons.
 */
var TOOLBAR_BUTTON = 'jp-NBToolbar-button';
/**
 * The class name added to a pressed button.
 */
var TOOLBAR_PRESSED = 'jp-mod-pressed';
/**
 * A class which provides a notebook toolbar widget.
 */
var NotebookToolbar = (function (_super) {
    __extends(NotebookToolbar, _super);
    /**
     * Construct a new toolbar widget.
     */
    function NotebookToolbar() {
        _super.call(this);
        this.addClass(NB_TOOLBAR);
        this.layout = new panel_1.PanelLayout();
    }
    /**
     * Add an item to the toolbar.
     *
     * @param name - The name of the widget to add to the toolbar.
     *
     * @param widget - The widget to add to the toolbar.
     *
     * @param after - The optional name of the item to insert after.
     *
     * #### Notes
     * An error is thrown if a widget of the same name is already given.
     * If `after` is not given, or the named widget is not in the toolbar,
     * the widget will be added to the end of the toolbar.
     */
    NotebookToolbar.prototype.add = function (name, widget, after) {
        var names = this.list();
        if (names.indexOf(name) !== -1) {
            throw new Error("A button named \"" + name + "\" was already added");
        }
        widget.addClass(TOOLBAR_ITEM);
        var layout = this.layout;
        var index = names.indexOf(after);
        if (index === -1) {
            layout.addWidget(widget);
        }
        else {
            layout.insertWidget(index + 1, widget);
        }
        Private.nameProperty.set(widget, name);
    };
    /**
     * Get an ordered list the toolbar item names.
     *
     * @returns A new array of the current toolbar item names.
     */
    NotebookToolbar.prototype.list = function () {
        var names = [];
        var layout = this.layout;
        for (var i = 0; i < layout.widgets.length; i++) {
            var widget = layout.widgets.at(i);
            names.push(Private.nameProperty.get(widget));
        }
        return names;
    };
    return NotebookToolbar;
}(widget_1.Widget));
exports.NotebookToolbar = NotebookToolbar;
/**
 * A widget which acts as a button in a toolbar.
 */
var ToolbarButton = (function (_super) {
    __extends(ToolbarButton, _super);
    /**
     * Construct a new toolbar button.
     */
    function ToolbarButton(options) {
        if (options === void 0) { options = {}; }
        _super.call(this, { node: Private.createNode() });
        options = options || {};
        this.addClass(TOOLBAR_BUTTON);
        this._onClick = options.onClick;
        if (options.className) {
            this.addClass(options.className);
        }
        this.node.title = options.tooltip || '';
    }
    /**
     * Dispose of the resources held by the widget.
     */
    ToolbarButton.prototype.dispose = function () {
        this._onClick = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    ToolbarButton.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'click':
                var cb = this._onClick;
                if (cb) {
                    cb();
                }
                break;
            case 'mousedown':
                this.addClass(TOOLBAR_PRESSED);
                break;
            case 'mouseup':
            case 'mouseout':
                this.removeClass(TOOLBAR_PRESSED);
                break;
            default:
                break;
        }
    };
    /**
     * Handle `after_attach` messages for the widget.
     */
    ToolbarButton.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('click', this);
        this.node.addEventListener('mousedown', this);
        this.node.addEventListener('mouseup', this);
        this.node.addEventListener('mouseout', this);
    };
    /**
     * Handle `before_detach` messages for the widget.
     */
    ToolbarButton.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('click', this);
        this.node.removeEventListener('mousedown', this);
        this.node.removeEventListener('mouseup', this);
        this.node.removeEventListener('mouseout', this);
    };
    return ToolbarButton;
}(widget_1.Widget));
exports.ToolbarButton = ToolbarButton;
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * An attached property for the name of a toolbar item.
     */
    Private.nameProperty = new properties_1.AttachedProperty({ name: 'name' });
    /**
     * Create the node for the toolbar button.
     */
    function createNode() {
        return document.createElement('span');
    }
    Private.createNode = createNode;
})(Private || (Private = {}));
