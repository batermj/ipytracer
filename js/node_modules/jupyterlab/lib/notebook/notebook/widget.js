// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var searching_1 = require('phosphor/lib/algorithm/searching');
var mimedata_1 = require('phosphor/lib/core/mimedata');
var properties_1 = require('phosphor/lib/core/properties');
var signaling_1 = require('phosphor/lib/core/signaling');
var dragdrop_1 = require('phosphor/lib/dom/dragdrop');
var query_1 = require('phosphor/lib/dom/query');
var panel_1 = require('phosphor/lib/ui/panel');
var widget_1 = require('phosphor/lib/ui/widget');
var dragscroll_1 = require('../../common/dragscroll');
var inspector_1 = require('../../inspector');
var cells_1 = require('../cells');
/**
 * The class name added to notebook widgets.
 */
var NB_CLASS = 'jp-Notebook';
/**
 * The class name added to notebook widget cells.
 */
var NB_CELL_CLASS = 'jp-Notebook-cell';
/**
 * The class name added to a notebook in edit mode.
 */
var EDIT_CLASS = 'jp-mod-editMode';
/**
 * The class name added to a notebook in command mode.
 */
var COMMAND_CLASS = 'jp-mod-commandMode';
/**
 * The class name added to the active cell.
 */
var ACTIVE_CLASS = 'jp-mod-active';
/**
 * The class name added to selected cells.
 */
var SELECTED_CLASS = 'jp-mod-selected';
/**
 * The class name added to an active cell when there are other selected cells.
 */
var OTHER_SELECTED_CLASS = 'jp-mod-multiSelected';
/**
 * The class name added to unconfined images.
 */
var UNCONFINED_CLASS = 'jp-mod-unconfined';
/**
 * The class name added to a drop target.
 */
var DROP_TARGET_CLASS = 'jp-mod-dropTarget';
/**
 * The class name added to a drop source.
 */
var DROP_SOURCE_CLASS = 'jp-mod-dropSource';
/**
 * The class name added to drag images.
 */
var DRAG_IMAGE_CLASS = 'jp-dragImage';
/**
 * The class name added to a filled circle.
 */
var FILLED_CIRCLE_CLASS = 'jp-filledCircle';
/**
 * The mimetype used for Jupyter cell data.
 */
exports.JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';
/**
 * The threshold in pixels to start a drag event.
 */
var DRAG_THRESHOLD = 5;
/**
 * A widget which renders static non-interactive notebooks.
 *
 * #### Notes
 * The widget model must be set separately and can be changed
 * at any time.  Consumers of the widget must account for a
 * `null` model, and may want to listen to the `modelChanged`
 * signal.
 */
var StaticNotebook = (function (_super) {
    __extends(StaticNotebook, _super);
    /**
     * Construct a notebook widget.
     */
    function StaticNotebook(options) {
        _super.call(this);
        this._mimetype = 'text/plain';
        this._model = null;
        this._rendermime = null;
        this._renderer = null;
        this.addClass(NB_CLASS);
        this._rendermime = options.rendermime;
        this.layout = new Private.NotebookPanelLayout();
        this._renderer = options.renderer;
    }
    Object.defineProperty(StaticNotebook.prototype, "model", {
        /**
         * The model for the widget.
         */
        get: function () {
            return this._model;
        },
        set: function (newValue) {
            newValue = newValue || null;
            if (this._model === newValue) {
                return;
            }
            var oldValue = this._model;
            this._model = newValue;
            // Trigger private, protected, and public changes.
            this._onModelChanged(oldValue, newValue);
            this.onModelChanged(oldValue, newValue);
            this.modelChanged.emit(void 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StaticNotebook.prototype, "rendermime", {
        /**
         * Get the rendermime instance used by the widget.
         */
        get: function () {
            return this._rendermime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StaticNotebook.prototype, "renderer", {
        /**
         * Get the renderer used by the widget.
         */
        get: function () {
            return this._renderer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StaticNotebook.prototype, "codeMimetype", {
        /**
         * Get the mimetype for code cells.
         */
        get: function () {
            return this._mimetype;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StaticNotebook.prototype, "widgets", {
        /**
         * A read-only sequence of the widgets in the notebook.
         */
        get: function () {
            return this.layout.widgets;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the widget.
     */
    StaticNotebook.prototype.dispose = function () {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        this._model = null;
        this._rendermime = null;
        this._renderer = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle a new model.
     *
     * #### Notes
     * This method is called after the model change has been handled
     * internally and before the `modelChanged` signal is emitted.
     * The default implementation is a no-op.
     */
    StaticNotebook.prototype.onModelChanged = function (oldValue, newValue) {
        // No-op.
    };
    /**
     * Handle changes to the notebook model content.
     *
     * #### Notes
     * The default implementation emits the `modelContentChanged` signal.
     */
    StaticNotebook.prototype.onModelContentChanged = function (model, args) {
        this.modelContentChanged.emit(void 0);
    };
    /**
     * Handle changes to the notebook model metadata.
     *
     * #### Notes
     * The default implementation updates the mimetypes of the code cells
     * when the `language_info` metadata changes.
     */
    StaticNotebook.prototype.onMetadataChanged = function (model, args) {
        switch (args.name) {
            case 'language_info':
                this._updateMimetype();
                this._updateCells();
                break;
            default:
                break;
        }
    };
    /**
     * Handle a cell being inserted.
     *
     * The default implementation is a no-op
     */
    StaticNotebook.prototype.onCellInserted = function (index, cell) {
        // This is a no-op.
    };
    /**
     * Handle a cell being moved.
     *
     * The default implementation is a no-op
     */
    StaticNotebook.prototype.onCellMoved = function (fromIndex, toIndex) {
        // This is a no-op.
    };
    /**
     * Handle a cell being removed.
     *
     * The default implementation is a no-op
     */
    StaticNotebook.prototype.onCellRemoved = function (cell) {
        // This is a no-op.
    };
    /**
     * Handle a new model on the widget.
     */
    StaticNotebook.prototype._onModelChanged = function (oldValue, newValue) {
        var _this = this;
        var layout = this.layout;
        if (oldValue) {
            oldValue.cells.changed.disconnect(this._onCellsChanged, this);
            oldValue.metadataChanged.disconnect(this.onMetadataChanged, this);
            oldValue.contentChanged.disconnect(this.onModelContentChanged, this);
            // TODO: reuse existing cell widgets if possible.
            for (var i = 0; i < layout.widgets.length; i++) {
                this._removeCell(0);
            }
        }
        if (!newValue) {
            this._mimetype = 'text/plain';
            return;
        }
        this._updateMimetype();
        var cells = newValue.cells;
        iteration_1.each(iteration_1.enumerate(cells), function (_a) {
            var i = _a[0], cell = _a[1];
            _this._insertCell(i, cell);
        });
        cells.changed.connect(this._onCellsChanged, this);
        newValue.contentChanged.connect(this.onModelContentChanged, this);
        newValue.metadataChanged.connect(this.onMetadataChanged, this);
    };
    /**
     * Handle a change cells event.
     */
    StaticNotebook.prototype._onCellsChanged = function (sender, args) {
        var _this = this;
        var index = 0;
        switch (args.type) {
            case 'add':
                index = args.newIndex;
                iteration_1.each(args.newValues, function (value) {
                    _this._insertCell(index++, value);
                });
                break;
            case 'move':
                this._moveCell(args.newIndex, args.oldIndex);
                break;
            case 'remove':
                iteration_1.each(args.oldValues, function (value) {
                    _this._removeCell(args.oldIndex);
                });
                break;
            case 'set':
                // TODO: reuse existing widgets if possible.
                index = args.newIndex;
                iteration_1.each(args.newValues, function (value) {
                    _this._removeCell(index);
                    _this._insertCell(index, value);
                    index++;
                });
                break;
            default:
                return;
        }
    };
    /**
     * Create a cell widget and insert into the notebook.
     */
    StaticNotebook.prototype._insertCell = function (index, cell) {
        var widget;
        switch (cell.type) {
            case 'code':
                widget = this._renderer.createCodeCell(cell, this._rendermime);
                break;
            case 'markdown':
                widget = this._renderer.createMarkdownCell(cell, this._rendermime);
                break;
            default:
                widget = this._renderer.createRawCell(cell);
        }
        widget.addClass(NB_CELL_CLASS);
        var layout = this.layout;
        layout.insertWidget(index, widget);
        this._updateCell(index);
        this.onCellInserted(index, widget);
    };
    /**
     * Move a cell widget.
     */
    StaticNotebook.prototype._moveCell = function (fromIndex, toIndex) {
        var layout = this.layout;
        layout.insertWidget(toIndex, layout.widgets.at(fromIndex));
        this.onCellMoved(fromIndex, toIndex);
    };
    /**
     * Remove a cell widget.
     */
    StaticNotebook.prototype._removeCell = function (index) {
        var layout = this.layout;
        var widget = layout.widgets.at(index);
        widget.parent = null;
        this.onCellRemoved(widget);
        widget.dispose();
    };
    /**
     * Update the cell widgets.
     */
    StaticNotebook.prototype._updateCells = function () {
        var _this = this;
        iteration_1.each(iteration_1.enumerate(this.widgets), function (_a) {
            var i = _a[0], widget = _a[1];
            _this._updateCell(i);
        });
    };
    /**
     * Update a cell widget.
     */
    StaticNotebook.prototype._updateCell = function (index) {
        var layout = this.layout;
        var child = layout.widgets.at(index);
        if (child instanceof cells_1.CodeCellWidget) {
            child.mimetype = this._mimetype;
        }
        this._renderer.updateCell(child);
    };
    /**
     * Update the mimetype of the notebook.
     */
    StaticNotebook.prototype._updateMimetype = function () {
        var cursor = this._model.getMetadata('language_info');
        var info = cursor.getValue();
        this._mimetype = this._renderer.getCodeMimetype(info);
    };
    return StaticNotebook;
}(widget_1.Widget));
exports.StaticNotebook = StaticNotebook;
// Define the signals for the `StaticNotebook` class.
signaling_1.defineSignal(StaticNotebook.prototype, 'modelChanged');
signaling_1.defineSignal(StaticNotebook.prototype, 'modelContentChanged');
/**
 * The namespace for the `StaticNotebook` class statics.
 */
var StaticNotebook;
(function (StaticNotebook) {
    /**
     * The default implementation of an `IRenderer`.
     */
    var Renderer = (function () {
        function Renderer() {
        }
        /**
         * Update a cell widget.
         *
         * #### Notes
         * The base implementation is a no-op.
         */
        Renderer.prototype.updateCell = function (cell) {
            // This is a no-op.
        };
        return Renderer;
    }());
    StaticNotebook.Renderer = Renderer;
})(StaticNotebook = exports.StaticNotebook || (exports.StaticNotebook = {}));
/**
 * A notebook widget that supports interactivity.
 */
var Notebook = (function (_super) {
    __extends(Notebook, _super);
    /**
     * Construct a notebook widget.
     */
    function Notebook(options) {
        var _this = this;
        _super.call(this, options);
        this._activeCellIndex = -1;
        this._activeCell = null;
        this._inspectionHandler = null;
        this._mode = 'command';
        this._drag = null;
        this._dragData = null;
        this._scrollHandler = null;
        this.node.tabIndex = -1; // Allow the widget to take focus.
        // Set up the inspection handler.
        this._inspectionHandler = new inspector_1.InspectionHandler({
            rendermime: this.rendermime
        });
        this.activeCellChanged.connect(function (s, cell) {
            _this._inspectionHandler.activeCell = cell;
        });
        this._scrollHandler = new dragscroll_1.DragScrollHandler({ node: this.node });
    }
    Object.defineProperty(Notebook.prototype, "inspectionHandler", {
        /**
         * Get the inspection handler used by the console.
         */
        get: function () {
            return this._inspectionHandler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Notebook.prototype, "mode", {
        /**
         * The interactivity mode of the notebook.
         */
        get: function () {
            return this._mode;
        },
        set: function (newValue) {
            var _this = this;
            // Always post an update request.
            this.update();
            if (newValue === this._mode) {
                return;
            }
            var oldValue = this._mode;
            this._mode = newValue;
            this.stateChanged.emit({ name: 'mode', oldValue: oldValue, newValue: newValue });
            var activeCell = this.activeCell;
            if (!activeCell) {
                return;
            }
            // Edit mode deselects all cells.
            if (newValue === 'edit') {
                iteration_1.each(this.widgets, function (widget) { _this.deselect(widget); });
                if (activeCell instanceof cells_1.MarkdownCellWidget) {
                    activeCell.rendered = false;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Notebook.prototype, "activeCellIndex", {
        /**
         * The active cell index of the notebook.
         *
         * #### Notes
         * The index will be clamped to the bounds of the notebook cells.
         */
        get: function () {
            if (!this.model) {
                return -1;
            }
            return this.model.cells.length ? this._activeCellIndex : -1;
        },
        set: function (newValue) {
            // Always post an update request.
            this.update();
            var oldValue = this._activeCellIndex;
            if (!this.model || !this.model.cells.length) {
                newValue = -1;
            }
            else {
                newValue = Math.max(newValue, 0);
                newValue = Math.min(newValue, this.model.cells.length - 1);
            }
            this._activeCellIndex = newValue;
            var cell = this.widgets.at(newValue);
            if (cell !== this._activeCell) {
                this._activeCell = cell;
                this.activeCellChanged.emit(cell);
            }
            if (newValue === oldValue) {
                return;
            }
            if (this.mode === 'edit' && cell instanceof cells_1.MarkdownCellWidget) {
                cell.rendered = false;
            }
            this.stateChanged.emit({ name: 'activeCellIndex', oldValue: oldValue, newValue: newValue });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Notebook.prototype, "activeCell", {
        /**
         * Get the active cell widget.
         */
        get: function () {
            return this._activeCell;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the widget.
     */
    Notebook.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._activeCell = null;
        this._inspectionHandler.dispose();
        this._inspectionHandler = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Select a cell widget.
     *
     * #### Notes
     * It is a no-op if the value does not change.
     * It will emit the `selectionChanged` signal.
     */
    Notebook.prototype.select = function (widget) {
        if (Private.selectedProperty.get(widget)) {
            return;
        }
        Private.selectedProperty.set(widget, true);
        this.selectionChanged.emit(void 0);
        this.update();
    };
    /**
     * Deselect a cell widget.
     *
     * #### Notes
     * It is a no-op if the value does not change.
     * It will emit the `selectionChanged` signal.
     */
    Notebook.prototype.deselect = function (widget) {
        if (!Private.selectedProperty.get(widget)) {
            return;
        }
        Private.selectedProperty.set(widget, false);
        this.selectionChanged.emit(void 0);
        this.update();
    };
    /**
     * Whether a cell is selected or is the active cell.
     */
    Notebook.prototype.isSelected = function (widget) {
        if (widget === this._activeCell) {
            return true;
        }
        return Private.selectedProperty.get(widget);
    };
    /**
     * Deselect all of the cells.
     */
    Notebook.prototype.deselectAll = function () {
        var changed = false;
        iteration_1.each(this.widgets, function (widget) {
            if (Private.selectedProperty.get(widget)) {
                changed = true;
            }
            Private.selectedProperty.set(widget, false);
        });
        if (changed) {
            this.selectionChanged.emit(void 0);
        }
        // Make sure we have a valid active cell.
        this.activeCellIndex = this.activeCellIndex;
    };
    /**
     * Scroll so that the active cell is visible.
     */
    Notebook.prototype.scrollToActiveCell = function () {
        if (this.activeCell) {
            query_1.scrollIntoViewIfNeeded(this.node, this.activeCell.node);
        }
    };
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the notebook panel's node. It should
     * not be called directly by user code.
     */
    Notebook.prototype.handleEvent = function (event) {
        if (!this.model || this.model.readOnly) {
            return;
        }
        switch (event.type) {
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'mouseup':
                this._evtMouseup(event);
                break;
            case 'mousemove':
                this._evtMousemove(event);
                break;
            case 'dblclick':
                this._evtDblClick(event);
                break;
            case 'focus':
                this._evtFocus(event);
                break;
            case 'blur':
                this._evtBlur(event);
                break;
            case 'p-dragenter':
                this._evtDragEnter(event);
                break;
            case 'p-dragleave':
                this._evtDragLeave(event);
                break;
            case 'p-dragover':
                this._evtDragOver(event);
                break;
            case 'p-drop':
                this._evtDrop(event);
                break;
            default:
                break;
        }
    };
    /**
     * Handle `after-attach` messages for the widget.
     */
    Notebook.prototype.onAfterAttach = function (msg) {
        _super.prototype.onAfterAttach.call(this, msg);
        var node = this.node;
        node.addEventListener('mousedown', this);
        node.addEventListener('dblclick', this);
        node.addEventListener('focus', this, true);
        node.addEventListener('blur', this, true);
        node.addEventListener('p-dragenter', this);
        node.addEventListener('p-dragleave', this);
        node.addEventListener('p-dragover', this);
        node.addEventListener('p-drop', this);
    };
    /**
     * Handle `before_detach` messages for the widget.
     */
    Notebook.prototype.onBeforeDetach = function (msg) {
        var node = this.node;
        node.removeEventListener('mousedown', this);
        node.removeEventListener('dblclick', this);
        node.removeEventListener('focus', this, true);
        node.removeEventListener('blur', this, true);
        node.removeEventListener('p-dragenter', this);
        node.removeEventListener('p-dragleave', this);
        node.removeEventListener('p-dragover', this);
        node.removeEventListener('p-drop', this);
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
    };
    /**
     * Handle `'activate-request'` messages.
     */
    Notebook.prototype.onActivateRequest = function (msg) {
        this._ensureFocus();
    };
    /**
     * Handle `update-request` messages sent to the widget.
     */
    Notebook.prototype.onUpdateRequest = function (msg) {
        var _this = this;
        var activeCell = this.activeCell;
        // Ensure we have the correct focus.
        if (this.node.contains(document.activeElement)) {
            this._ensureFocus();
        }
        // Set the appropriate classes on the cells.
        if (this.mode === 'edit') {
            this.addClass(EDIT_CLASS);
            this.removeClass(COMMAND_CLASS);
        }
        else {
            this.addClass(COMMAND_CLASS);
            this.removeClass(EDIT_CLASS);
        }
        if (activeCell) {
            activeCell.addClass(ACTIVE_CLASS);
        }
        var count = 0;
        iteration_1.each(this.widgets, function (widget) {
            if (widget !== activeCell) {
                widget.removeClass(ACTIVE_CLASS);
            }
            widget.removeClass(OTHER_SELECTED_CLASS);
            if (_this.isSelected(widget)) {
                widget.addClass(SELECTED_CLASS);
                count++;
            }
            else {
                widget.removeClass(SELECTED_CLASS);
            }
        });
        if (count > 1) {
            activeCell.addClass(OTHER_SELECTED_CLASS);
        }
    };
    /**
     * Handle a cell being inserted.
     */
    Notebook.prototype.onCellInserted = function (index, cell) {
        cell.editor.edgeRequested.connect(this._onEdgeRequest, this);
        // Trigger an update of the active cell.
        this.activeCellIndex = this.activeCellIndex;
    };
    /**
     * Handle a cell being moved.
     */
    Notebook.prototype.onCellMoved = function (fromIndex, toIndex) {
        if (fromIndex === this.activeCellIndex) {
            this.activeCellIndex = toIndex;
        }
    };
    /**
     * Handle a cell being removed.
     */
    Notebook.prototype.onCellRemoved = function (cell) {
        // Trigger an update of the active cell.
        this.activeCellIndex = this.activeCellIndex;
        if (this.isSelected(cell)) {
            this.selectionChanged.emit(void 0);
        }
    };
    /**
     * Handle a new model.
     */
    Notebook.prototype.onModelChanged = function (oldValue, newValue) {
        // Try to set the active cell index to 0.
        // It will be set to `-1` if there is no new model or the model is empty.
        this.activeCellIndex = 0;
    };
    /**
     * Handle edge request signals from cells.
     */
    Notebook.prototype._onEdgeRequest = function (widget, location) {
        var prev = this.activeCellIndex;
        if (location === 'top') {
            this.activeCellIndex--;
            // Move the cursor to the first position on the last line.
            if (this.activeCellIndex < prev) {
                var lastLine = this.activeCell.editor.getLastLine();
                this.activeCell.editor.setCursor(lastLine, 0);
            }
        }
        else {
            this.activeCellIndex++;
            // Move the cursor to the first character.
            if (this.activeCellIndex > prev) {
                this.activeCell.editor.setCursorPosition(0);
            }
        }
    };
    Notebook.prototype._ensureFocus = function () {
        var activeCell = this.activeCell;
        if (this.mode === 'edit' && activeCell) {
            activeCell.editor.activate();
        }
        else if (!this.node.contains(document.activeElement)) {
            this.node.focus();
        }
        else {
            // If an editor currently has focus, focus our node.
            // Otherwise, another input field has focus and should keep it.
            var w = searching_1.find(this.layout, function (widget) {
                return widget.editor.hasFocus();
            });
            if (w) {
                this.node.focus();
            }
        }
    };
    /**
     * Find the cell index containing the target html element.
     *
     * #### Notes
     * Returns -1 if the cell is not found.
     */
    Notebook.prototype._findCell = function (node) {
        // Trace up the DOM hierarchy to find the root cell node.
        // Then find the corresponding child and select it.
        while (node && node !== this.node) {
            if (node.classList.contains(NB_CELL_CLASS)) {
                var i = searching_1.findIndex(this.widgets, function (widget) { return widget.node === node; });
                if (i !== -1) {
                    return i;
                }
                break;
            }
            node = node.parentElement;
        }
        return -1;
    };
    /**
     * Handle `mousedown` events for the widget.
     */
    Notebook.prototype._evtMouseDown = function (event) {
        var target = event.target;
        var i = this._findCell(target);
        var shouldDrag = false;
        if (i !== -1) {
            var widget = this.widgets.at(i);
            // Event is on a cell but not in its editor, switch to command mode.
            if (!widget.editor.node.contains(target)) {
                this.mode = 'command';
                shouldDrag = widget.promptNode.contains(target);
            }
            if (event.shiftKey) {
                shouldDrag = false;
                this._extendSelectionTo(i);
                // Prevent text select behavior.
                event.preventDefault();
                event.stopPropagation();
            }
            else {
                if (!this.isSelected(widget)) {
                    this.deselectAll();
                }
            }
            // Set the cell as the active one.
            // This must be done *after* setting the mode above.
            this.activeCellIndex = i;
        }
        // Left mouse press for drag start.
        if (event.button === 0 && shouldDrag) {
            this._dragData = { pressX: event.clientX, pressY: event.clientY, index: i };
            document.addEventListener('mouseup', this, true);
            document.addEventListener('mousemove', this, true);
        }
    };
    /**
     * Handle the `'mouseup'` event for the widget.
     */
    Notebook.prototype._evtMouseup = function (event) {
        if (event.button !== 0 || !this._drag) {
            document.removeEventListener('mousemove', this, true);
            document.removeEventListener('mouseup', this, true);
            return;
        }
        event.preventDefault();
        event.stopPropagation();
    };
    /**
     * Handle the `'mousemove'` event for the widget.
     */
    Notebook.prototype._evtMousemove = function (event) {
        event.preventDefault();
        event.stopPropagation();
        // Bail if we are the one dragging.
        if (this._drag) {
            return;
        }
        // Check for a drag initialization.
        var data = this._dragData;
        var dx = Math.abs(event.clientX - data.pressX);
        var dy = Math.abs(event.clientY - data.pressY);
        if (dx < DRAG_THRESHOLD && dy < DRAG_THRESHOLD) {
            return;
        }
        this._startDrag(data.index, event.clientX, event.clientY);
    };
    /**
     * Handle the `'p-dragenter'` event for the widget.
     */
    Notebook.prototype._evtDragEnter = function (event) {
        if (!event.mimeData.hasData(exports.JUPYTER_CELL_MIME)) {
            return;
        }
        this._scrollHandler.handleDragEvent(event);
        event.preventDefault();
        event.stopPropagation();
        var target = event.target;
        var index = this._findCell(target);
        if (index === -1) {
            return;
        }
        var widget = this.layout.widgets.at(index);
        widget.node.classList.add(DROP_TARGET_CLASS);
    };
    /**
     * Handle the `'p-dragleave'` event for the widget.
     */
    Notebook.prototype._evtDragLeave = function (event) {
        if (!event.mimeData.hasData(exports.JUPYTER_CELL_MIME)) {
            return;
        }
        this._scrollHandler.handleDragEvent(event);
        event.preventDefault();
        event.stopPropagation();
        var elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);
        if (elements.length) {
            elements[0].classList.remove(DROP_TARGET_CLASS);
        }
    };
    /**
     * Handle the `'p-dragover'` event for the widget.
     */
    Notebook.prototype._evtDragOver = function (event) {
        if (!event.mimeData.hasData(exports.JUPYTER_CELL_MIME)) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        event.dropAction = event.proposedAction;
        var elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);
        if (elements.length) {
            elements[0].classList.remove(DROP_TARGET_CLASS);
        }
        this._scrollHandler.handleDragEvent(event);
        var target = event.target;
        var index = this._findCell(target);
        if (index === -1) {
            return;
        }
        var widget = this.layout.widgets.at(index);
        widget.node.classList.add(DROP_TARGET_CLASS);
    };
    /**
     * Handle the `'p-drop'` event for the widget.
     */
    Notebook.prototype._evtDrop = function (event) {
        if (!event.mimeData.hasData(exports.JUPYTER_CELL_MIME)) {
            return;
        }
        this._scrollHandler.handleDragEvent(event);
        event.preventDefault();
        event.stopPropagation();
        if (event.proposedAction === 'none') {
            event.dropAction = 'none';
            return;
        }
        event.dropAction = event.proposedAction;
        var target = event.target;
        while (target && target.parentElement) {
            if (target.classList.contains(DROP_TARGET_CLASS)) {
                target.classList.remove(DROP_TARGET_CLASS);
                break;
            }
            target = target.parentElement;
        }
        // Find the target cell and insert the copied cells.
        var index = this._findCell(target);
        if (index === -1) {
            index = this.widgets.length;
        }
        var model = this.model;
        var values = event.mimeData.getData(exports.JUPYTER_CELL_MIME);
        // Insert the copies of the original cells.
        iteration_1.each(values, function (value) {
            var cell;
            switch (value.cell_type) {
                case 'code':
                    cell = model.factory.createCodeCell(value);
                    break;
                case 'markdown':
                    cell = model.factory.createMarkdownCell(value);
                    break;
                default:
                    cell = model.factory.createRawCell(value);
                    break;
            }
            model.cells.insert(index, cell);
        });
        // Activate the last cell.
        this.activeCellIndex = index + values.length - 1;
    };
    /**
     * Start a drag event.
     */
    Notebook.prototype._startDrag = function (index, clientX, clientY) {
        var _this = this;
        var cells = this.model.cells;
        var selected = [];
        var toremove = [];
        iteration_1.each(iteration_1.enumerate(this.widgets), function (_a) {
            var i = _a[0], widget = _a[1];
            var cell = cells.at(i);
            if (_this.isSelected(widget)) {
                widget.addClass(DROP_SOURCE_CLASS);
                selected.push(cell.toJSON());
                toremove.push(widget);
            }
        });
        // Create the drag image.
        var dragImage = Private.createDragImage(selected.length);
        // Set up the drag event.
        this._drag = new dragdrop_1.Drag({
            mimeData: new mimedata_1.MimeData(),
            dragImage: dragImage,
            supportedActions: 'move',
            proposedAction: 'move'
        });
        this._drag.mimeData.setData(exports.JUPYTER_CELL_MIME, selected);
        // Remove mousemove and mouseup listeners and start the drag.
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        this._drag.start(clientX, clientY).then(function (action) {
            _this._drag = null;
            iteration_1.each(toremove, function (widget) { widget.removeClass(DROP_SOURCE_CLASS); });
            if (action === 'none') {
                return;
            }
            var activeCell = cells.at(_this.activeCellIndex);
            iteration_1.each(toremove, function (widget) {
                _this.model.cells.remove(widget.model);
            });
            _this.activeCellIndex = searching_1.indexOf(cells, activeCell);
        });
    };
    /**
     * Handle `focus` events for the widget.
     */
    Notebook.prototype._evtFocus = function (event) {
        var target = event.target;
        var i = this._findCell(target);
        if (i !== -1) {
            var widget = this.widgets.at(i);
            // If the editor itself does not have focus, ensure command mode.
            if (!widget.editor.node.contains(target)) {
                this.mode = 'command';
            }
            this.activeCellIndex = i;
            // If the editor has focus, ensure edit mode.
            if (widget.editor.node.contains(target)) {
                this.mode = 'edit';
            }
        }
        else {
            // No cell has focus, ensure command mode.
            this.mode = 'command';
        }
    };
    /**
     * Handle `blur` events for the widget.
     */
    Notebook.prototype._evtBlur = function (event) {
        var target = event.relatedTarget;
        if (!this.node.contains(target)) {
            this.mode = 'command';
        }
    };
    /**
     * Handle `dblclick` events for the widget.
     */
    Notebook.prototype._evtDblClick = function (event) {
        var model = this.model;
        if (!model || model.readOnly) {
            return;
        }
        var target = event.target;
        var i = this._findCell(target);
        if (i === -1) {
            return;
        }
        var layout = this.layout;
        var cell = model.cells.at(i);
        var widget = layout.widgets.at(i);
        if (cell.type === 'markdown') {
            widget.rendered = false;
            widget.activate();
            return;
        }
        else if (target.localName === 'img') {
            target.classList.toggle(UNCONFINED_CLASS);
        }
    };
    /**
     * Extend the selection to a given index.
     */
    Notebook.prototype._extendSelectionTo = function (index) {
        var activeIndex = this.activeCellIndex;
        var j = index;
        // extend the existing selection.
        if (j > activeIndex) {
            while (j > activeIndex) {
                Private.selectedProperty.set(this.widgets.at(j), true);
                j--;
            }
        }
        else if (j < activeIndex) {
            while (j < activeIndex) {
                Private.selectedProperty.set(this.widgets.at(j), true);
                j++;
            }
        }
        Private.selectedProperty.set(this.widgets.at(activeIndex), true);
        this.selectionChanged.emit(void 0);
    };
    return Notebook;
}(StaticNotebook));
exports.Notebook = Notebook;
// Define the signals for the `Notebook` class.
signaling_1.defineSignal(Notebook.prototype, 'activeCellChanged');
signaling_1.defineSignal(Notebook.prototype, 'selectionChanged');
signaling_1.defineSignal(Notebook.prototype, 'stateChanged');
/**
 * The namespace for the `Notebook` class statics.
 */
var Notebook;
(function (Notebook) {
    /**
     * The default implementation of an `IRenderer`.
     */
    var Renderer = (function (_super) {
        __extends(Renderer, _super);
        function Renderer() {
            _super.apply(this, arguments);
        }
        return Renderer;
    }(StaticNotebook.Renderer));
    Notebook.Renderer = Renderer;
})(Notebook = exports.Notebook || (exports.Notebook = {}));
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * An attached property for the selected state of a cell.
     */
    Private.selectedProperty = new properties_1.AttachedProperty({
        name: 'selected',
        value: false
    });
    /**
     * A custom panel layout for the notebook.
     */
    var NotebookPanelLayout = (function (_super) {
        __extends(NotebookPanelLayout, _super);
        function NotebookPanelLayout() {
            _super.apply(this, arguments);
        }
        /**
         * A message handler invoked on an `'update-request'` message.
         *
         * #### Notes
         * This is a reimplementation of the base class method,
         * and is a no-op.
         */
        NotebookPanelLayout.prototype.onUpdateRequest = function (msg) {
            // This is a no-op.
        };
        return NotebookPanelLayout;
    }(panel_1.PanelLayout));
    Private.NotebookPanelLayout = NotebookPanelLayout;
    /**
     * Create a cell drag image.
     */
    function createDragImage(count) {
        var node = document.createElement('div');
        var span = document.createElement('span');
        span.textContent = "" + count;
        span.className = FILLED_CIRCLE_CLASS;
        node.appendChild(span);
        node.className = DRAG_IMAGE_CLASS;
        return node;
    }
    Private.createDragImage = createDragImage;
})(Private || (Private = {}));
//# sourceMappingURL=widget.js.map