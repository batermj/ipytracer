// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var services_1 = require('@jupyterlab/services');
var searching_1 = require('phosphor/lib/algorithm/searching');
var signaling_1 = require('phosphor/lib/core/signaling');
var observablevector_1 = require('../../common/observablevector');
/**
 * An model that maintains a list of output data.
 */
var OutputAreaModel = (function () {
    /**
     * Construct a new observable outputs instance.
     */
    function OutputAreaModel() {
        this.clearNext = false;
        this.list = null;
        this.list = new observablevector_1.ObservableVector();
        this.list.changed.connect(this._onListChanged, this);
    }
    Object.defineProperty(OutputAreaModel.prototype, "length", {
        /**
         * Get the length of the items in the model.
         */
        get: function () {
            return this.list ? this.list.length : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutputAreaModel.prototype, "isDisposed", {
        /**
         * Test whether the model is disposed.
         */
        get: function () {
            return this.list === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources used by the model.
     */
    OutputAreaModel.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this.disposed.emit(void 0);
        this.list.clear();
        this.list = null;
        signaling_1.clearSignalData(this);
    };
    /**
     * Get an item at the specified index.
     */
    OutputAreaModel.prototype.get = function (index) {
        return this.list.at(index);
    };
    /**
     * Add an output, which may be combined with previous output.
     *
     * #### Notes
     * The output bundle is copied.
     * Contiguous stream outputs of the same `name` are combined.
     */
    OutputAreaModel.prototype.add = function (output) {
        // If we received a delayed clear message, then clear now.
        if (this.clearNext) {
            this.clear();
            this.clearNext = false;
        }
        if (output.output_type === 'input_request') {
            this.list.pushBack(output);
        }
        // Make a copy of the output bundle.
        var value = JSON.parse(JSON.stringify(output));
        // Join multiline text outputs.
        if (value.output_type === 'stream') {
            if (Array.isArray(value.text)) {
                value.text = value.text.join('\n');
            }
        }
        // Consolidate outputs if they are stream outputs of the same kind.
        var index = this.length - 1;
        var lastOutput = this.get(index);
        if (value.output_type === 'stream'
            && lastOutput && lastOutput.output_type === 'stream'
            && value.name === lastOutput.name) {
            // In order to get a list change event, we add the previous
            // text to the current item and replace the previous item.
            // This also replaces the metadata of the last item.
            var text = value.text;
            value.text = lastOutput.text + text;
            this.list.set(index, value);
            return index;
        }
        else {
            switch (value.output_type) {
                case 'stream':
                case 'execute_result':
                case 'display_data':
                case 'error':
                    return this.list.pushBack(value);
                default:
                    break;
            }
        }
        return -1;
    };
    /**
     * Clear all of the output.
     *
     * @param wait Delay clearing the output until the next message is added.
     */
    OutputAreaModel.prototype.clear = function (wait) {
        if (wait === void 0) { wait = false; }
        if (wait) {
            this.clearNext = true;
            return;
        }
        this.list.clear();
    };
    /**
     * Add a mime type to an output data bundle.
     *
     * @param output - The output to augment.
     *
     * @param mimetype - The mimetype to add.
     *
     * @param value - The value to add.
     *
     * #### Notes
     * The output must be contained in the model, or an error will be thrown.
     * Only non-existent types can be added.
     * Types are validated before being added.
     */
    OutputAreaModel.prototype.addMimeData = function (output, mimetype, value) {
        var index = searching_1.indexOf(this.list, output);
        if (index === -1) {
            throw new Error("Cannot add data to non-tracked bundle");
        }
        if (mimetype in output.data) {
            console.warn("Cannot add existing key '" + mimetype + "' to bundle");
            return;
        }
        if (services_1.nbformat.validateMimeValue(mimetype, value)) {
            output.data[mimetype] = value;
        }
        else {
            console.warn("Refusing to add invalid mime value of type " + mimetype + " to output");
        }
    };
    /**
     * Execute code on a kernel and send outputs to the model.
     */
    OutputAreaModel.prototype.execute = function (code, kernel) {
        var _this = this;
        // Override the default for `stop_on_error`.
        var content = {
            code: code,
            stop_on_error: true
        };
        this.clear();
        return new Promise(function (resolve, reject) {
            var future = kernel.requestExecute(content);
            // Handle published messages.
            future.onIOPub = function (msg) {
                var msgType = msg.header.msg_type;
                switch (msgType) {
                    case 'execute_result':
                    case 'display_data':
                    case 'stream':
                    case 'error':
                        var model = msg.content;
                        model.output_type = msgType;
                        _this.add(model);
                        break;
                    case 'clear_output':
                        _this.clear(msg.content.wait);
                        break;
                    default:
                        break;
                }
            };
            // Handle the execute reply.
            future.onReply = function (msg) {
                resolve(msg);
                // API responses that contain a pager are special cased and their type
                // is overriden from 'execute_reply' to 'display_data' in order to
                // render output.
                var content = msg.content;
                var payload = content && content.payload;
                if (!payload || !payload.length) {
                    return;
                }
                var pages = payload.filter(function (i) { return i.source === 'page'; });
                if (!pages.length) {
                    return;
                }
                var page = JSON.parse(JSON.stringify(pages[0]));
                var model = {
                    output_type: 'display_data',
                    data: page.data,
                    metadata: {}
                };
                _this.add(model);
            };
            // Handle stdin.
            future.onStdin = function (msg) {
                if (services_1.KernelMessage.isInputRequestMsg(msg)) {
                    _this.add({
                        output_type: 'input_request',
                        prompt: msg.content.prompt,
                        password: msg.content.password,
                        kernel: kernel
                    });
                }
            };
        });
    };
    /**
     * Handle a change to the list.
     */
    OutputAreaModel.prototype._onListChanged = function (sender, args) {
        this.changed.emit(args);
    };
    return OutputAreaModel;
}());
exports.OutputAreaModel = OutputAreaModel;
// Define the signals for the `OutputAreaModel` class.
signaling_1.defineSignal(OutputAreaModel.prototype, 'changed');
signaling_1.defineSignal(OutputAreaModel.prototype, 'disposed');
//# sourceMappingURL=model.js.map