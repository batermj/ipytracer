import { Kernel, KernelMessage } from '@jupyterlab/services';
import { ISignal } from 'phosphor/lib/core/signaling';
import { Message } from 'phosphor/lib/core/messaging';
import { Widget } from 'phosphor/lib/ui/widget';
import { IChangedArgs } from '../../common/interfaces';
import { RenderMime } from '../../rendermime';
import { OutputAreaWidget } from '../output-area';
import { ICellEditorWidget } from './editor';
import { ICellModel, ICodeCellModel, IMarkdownCellModel, IRawCellModel } from './model';
/**
 * A base cell widget.
 */
export declare class BaseCellWidget extends Widget {
    /**
     * Construct a new base cell widget.
     */
    constructor(options: BaseCellWidget.IOptions);
    /**
     * A signal emitted when the model of the cell changes.
     */
    modelChanged: ISignal<BaseCellWidget, void>;
    /**
     * The model used by the widget.
     */
    model: ICellModel;
    /**
     * Get the prompt node used by the cell.
     */
    readonly promptNode: HTMLElement;
    /**
     * Get the editor widget used by the cell.
     *
     * #### Notes
     * This is a ready-only property.
     */
    readonly editor: ICellEditorWidget;
    /**
     * The mimetype used by the cell.
     */
    mimetype: string;
    /**
     * The read only state of the cell.
     */
    readOnly: boolean;
    /**
     * The trusted state of the cell.
     */
    trusted: boolean;
    /**
     * Set the prompt for the widget.
     */
    setPrompt(value: string): void;
    /**
     * Dispose of the resources held by the widget.
     */
    dispose(): void;
    /**
     * Handle `after-attach` messages.
     */
    protected onAfterAttach(msg: Message): void;
    /**
     * Handle `'activate-request'` messages.
     */
    protected onActivateRequest(msg: Message): void;
    /**
     * Handle `update-request` messages.
     */
    protected onUpdateRequest(msg: Message): void;
    /**
     * Handle changes in the model.
     *
     * #### Notes
     * Subclasses may reimplement this method as needed.
     */
    protected onModelStateChanged(model: ICellModel, args: IChangedArgs<any>): void;
    /**
     * Handle changes in the model.
     */
    protected onMetadataChanged(model: ICellModel, args: IChangedArgs<any>): void;
    /**
     * Handle a new model.
     *
     * #### Notes
     * This method is called after the model change has been handled
     * internally and before the `modelChanged` signal is emitted.
     * The default implementation is a no-op.
     */
    protected onModelChanged(oldValue: ICellModel, newValue: ICellModel): void;
    /**
     * Render an input instead of the text editor.
     */
    protected renderInput(widget: Widget): void;
    /**
     * Show the text editor.
     */
    protected showEditor(): void;
    /**
     * Handle a model change.
     */
    private _onModelChanged(oldValue, newValue);
    private _input;
    private _editor;
    private _model;
    private _mimetype;
    private _readOnly;
    private _trustedCursor;
    private _trusted;
}
/**
 * The namespace for the `BaseCellWidget` class statics.
 */
export declare namespace BaseCellWidget {
    /**
     * An options object for initializing a base cell widget.
     */
    interface IOptions {
        /**
         * A renderer for creating cell widgets.
         *
         * The default is a shared renderer instance.
         */
        renderer: IRenderer;
    }
    /**
     * A renderer for creating cell widgets.
     */
    interface IRenderer {
        /**
         * Create a new cell editor for the widget.
         */
        createCellEditor(): ICellEditorWidget;
        /**
         * Create a new input area for the widget.
         */
        createInputArea(editor: ICellEditorWidget): InputAreaWidget;
    }
    /**
     * The default implementation of an `IRenderer`.
     */
    abstract class Renderer implements IRenderer {
        /**
         * Create a new cell editor for the widget.
         */
        abstract createCellEditor(): ICellEditorWidget;
        /**
         * Create a new input area for the widget.
         */
        createInputArea(editor: ICellEditorWidget): InputAreaWidget;
    }
}
/**
 * A widget for a code cell.
 */
export declare class CodeCellWidget extends BaseCellWidget {
    /**
     * Construct a code cell widget.
     */
    constructor(options: CodeCellWidget.IOptions);
    /**
     * The model used by the widget.
     */
    model: ICodeCellModel;
    /**
     * Dispose of the resources used by the widget.
     */
    dispose(): void;
    /**
     * Execute the cell given a kernel.
     */
    execute(kernel: Kernel.IKernel): Promise<KernelMessage.IExecuteReplyMsg>;
    /**
     * Handle `update-request` messages.
     */
    protected onUpdateRequest(msg: Message): void;
    /**
     * Handle the widget receiving a new model.
     */
    protected onModelChanged(oldValue: ICellModel, newValue: ICellModel): void;
    /**
     * Handle changes in the model.
     */
    protected onModelStateChanged(model: ICellModel, args: IChangedArgs<any>): void;
    /**
     * Handle changes in the metadata.
     */
    protected onMetadataChanged(model: ICellModel, args: IChangedArgs<any>): void;
    private _renderer;
    private _rendermime;
    private _output;
    private _collapsedCursor;
    private _scrolledCursor;
}
/**
 * The namespace for the `CodeCellWidget` class statics.
 */
export declare namespace CodeCellWidget {
    /**
     * An options object for initializing a base cell widget.
     */
    interface IOptions {
        /**
         * A renderer for creating cell widgets.
         *
         * The default is a shared renderer instance.
         */
        renderer: IRenderer;
        /**
         * The mime renderer for the cell widget.
         */
        rendermime: RenderMime;
    }
    /**
     * A renderer for creating code cell widgets.
     */
    interface IRenderer extends BaseCellWidget.IRenderer {
        /**
         * Create a new output area for the widget.
         */
        createOutputArea(rendermime: RenderMime): OutputAreaWidget;
    }
    /**
     * The default implementation of an `IRenderer`.
     */
    abstract class Renderer extends BaseCellWidget.Renderer implements IRenderer {
        /**
         * Create an output area widget.
         */
        createOutputArea(rendermime: RenderMime): OutputAreaWidget;
    }
}
/**
 * A widget for a Markdown cell.
 *
 * #### Notes
 * Things get complicated if we want the rendered text to update
 * any time the text changes, the text editor model changes,
 * or the input area model changes.  We don't support automatically
 * updating the rendered text in all of these cases.
 */
export declare class MarkdownCellWidget extends BaseCellWidget {
    /**
     * Construct a Markdown cell widget.
     */
    constructor(options: MarkdownCellWidget.IOptions);
    /**
     * The model used by the widget.
     */
    model: IMarkdownCellModel;
    /**
     * Whether the cell is rendered.
     */
    rendered: boolean;
    /**
     * Dispose of the resource held by the widget.
     */
    dispose(): void;
    /**
     * Handle `update-request` messages.
     */
    protected onUpdateRequest(msg: Message): void;
    private _rendermime;
    private _output;
    private _rendered;
    private _prev;
}
/**
 * The namespace for the `CodeCellWidget` class statics.
 */
export declare namespace MarkdownCellWidget {
    /**
     * An options object for initializing a base cell widget.
     */
    interface IOptions {
        /**
         * A renderer for creating cell widgets.
         *
         * The default is a shared renderer instance.
         */
        renderer: BaseCellWidget.IRenderer;
        /**
         * The mime renderer for the cell widget.
         */
        rendermime: RenderMime;
    }
}
/**
 * A widget for a raw cell.
 */
export declare class RawCellWidget extends BaseCellWidget {
    /**
     * Construct a raw cell widget.
     */
    constructor(options: BaseCellWidget.IOptions);
    /**
     * The model used by the widget.
     */
    model: IRawCellModel;
}
/**
 * An input area widget, which hosts a prompt and an editor widget.
 */
export declare class InputAreaWidget extends Widget {
    /**
     * Construct an input area widget.
     */
    constructor(editor: ICellEditorWidget);
    /**
     * Get the prompt node used by the cell.
     */
    readonly promptNode: HTMLElement;
    /**
     * Render an input instead of the text editor.
     */
    renderInput(widget: Widget): void;
    /**
     * Show the text editor.
     */
    showEditor(): void;
    /**
     * Set the prompt of the input area.
     */
    setPrompt(value: string): void;
    private _prompt;
    private _editor;
    private _rendered;
}
