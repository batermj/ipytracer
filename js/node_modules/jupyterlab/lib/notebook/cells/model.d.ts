import { nbformat } from '@jupyterlab/services';
import { JSONValue } from 'phosphor/lib/algorithm/json';
import { IIterator } from 'phosphor/lib/algorithm/iteration';
import { IDisposable } from 'phosphor/lib/core/disposable';
import { ISignal } from 'phosphor/lib/core/signaling';
import { IChangedArgs } from '../../common/interfaces';
import { IMetadataCursor } from '../common/metadata';
import { OutputAreaModel } from '../output-area';
/**
 * The definition of a model object for a cell.
 */
export interface ICellModel extends IDisposable {
    /**
     * The type of the cell.
     */
    readonly type: nbformat.CellType;
    /**
     * A signal emitted when the content of the model changes.
     */
    contentChanged: ISignal<ICellModel, void>;
    /**
     * A signal emitted when a metadata field changes.
     */
    metadataChanged: ISignal<ICellModel, IChangedArgs<JSONValue>>;
    /**
     * A signal emitted when a model state changes.
     */
    stateChanged: ISignal<ICellModel, IChangedArgs<any>>;
    /**
     * The input content of the cell.
     */
    source: string;
    /**
     * Serialize the model to JSON.
     */
    toJSON(): nbformat.ICell;
    /**
     * Get a metadata cursor for the cell.
     *
     * #### Notes
     * Metadata associated with the nbformat spec are set directly
     * on the model.  This method is used to interact with a namespaced
     * set of metadata on the cell.
     */
    getMetadata(name: string): IMetadataCursor;
    /**
     * List the metadata namespace keys for the notebook.
     *
     * #### Notes
     * Metadata associated with the nbformat are not included.
     */
    listMetadata(): IIterator<string>;
}
/**
 * The definition of a code cell.
 */
export interface ICodeCellModel extends ICellModel {
    /**
     * The type of the cell.
     *
     * #### Notes
     * This is a read-only property.
     */
    type: 'code';
    /**
     * The code cell's prompt number. Will be null if the cell has not been run.
     */
    executionCount: nbformat.ExecutionCount;
    /**
     * The cell outputs.
     */
    outputs: OutputAreaModel;
}
/**
 * The definition of a markdown cell.
 */
export interface IMarkdownCellModel extends ICellModel {
    /**
     * The type of the cell.
     */
    type: 'markdown';
}
/**
 * The definition of a raw cell.
 */
export interface IRawCellModel extends ICellModel {
    /**
     * The type of the cell.
     */
    type: 'raw';
}
/**
 * An implementation of the cell model.
 */
export declare class CellModel implements ICellModel {
    /**
     * Construct a cell model from optional cell content.
     */
    constructor(cell?: nbformat.IBaseCell);
    /**
     * A signal emitted when the state of the model changes.
     */
    contentChanged: ISignal<ICellModel, void>;
    /**
     * A signal emitted when a metadata field changes.
     */
    metadataChanged: ISignal<ICellModel, IChangedArgs<any>>;
    /**
     * A signal emitted when a model state changes.
     */
    stateChanged: ISignal<ICellModel, IChangedArgs<any>>;
    /**
     * The input content of the cell.
     */
    source: string;
    /**
     * Get whether the model is disposed.
     */
    readonly isDisposed: boolean;
    /**
     * Dispose of the resources held by the model.
     */
    dispose(): void;
    /**
     * Serialize the model to JSON.
     */
    toJSON(): nbformat.ICell;
    /**
     * Get a metadata cursor for the cell.
     *
     * #### Notes
     * Metadata associated with the nbformat spec are set directly
     * on the model.  This method is used to interact with a namespaced
     * set of metadata on the cell.
     */
    getMetadata(name: string): IMetadataCursor;
    /**
     * List the metadata namespace keys for the notebook.
     *
     * #### Notes
     * Metadata associated with the nbformat are not included.
     */
    listMetadata(): IIterator<string>;
    /**
     * Set the cursor data for a given field.
     */
    protected setCursorData(name: string, newValue: any): void;
    /**
     * The type of cell.
     */
    type: nbformat.CellType;
    private _metadata;
    private _cursors;
    private _source;
}
/**
 * An implementation of a raw cell model.
 */
export declare class RawCellModel extends CellModel {
    /**
     * The type of the cell.
     */
    readonly type: 'raw';
}
/**
 * An implementation of a markdown cell model.
 */
export declare class MarkdownCellModel extends CellModel {
    /**
     * The type of the cell.
     */
    readonly type: 'markdown';
}
/**
 * An implementation of a code cell Model.
 */
export declare class CodeCellModel extends CellModel implements ICodeCellModel {
    /**
     * Construct a new code cell with optional original cell content.
     */
    constructor(cell?: nbformat.ICell);
    /**
     * The type of the cell.
     */
    readonly type: 'code';
    /**
     * The execution count of the cell.
     */
    executionCount: nbformat.ExecutionCount;
    /**
     * The cell outputs.
     */
    readonly outputs: OutputAreaModel;
    /**
     * Dispose of the resources held by the model.
     */
    dispose(): void;
    /**
     * Serialize the model to JSON.
     */
    toJSON(): nbformat.ICodeCell;
    private _outputs;
    private _executionCount;
}
