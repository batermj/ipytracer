// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var signaling_1 = require('phosphor/lib/core/signaling');
var panel_1 = require('phosphor/lib/ui/panel');
var widget_1 = require('phosphor/lib/ui/widget');
var output_area_1 = require('../output-area');
/**
 * The class name added to cell widgets.
 */
var CELL_CLASS = 'jp-Cell';
/**
 * The class name added to the prompt area of cell.
 */
var PROMPT_CLASS = 'jp-Cell-prompt';
/**
 * The class name added to input area widgets.
 */
var INPUT_CLASS = 'jp-InputArea';
/**
 * The class name added to the editor area of the cell.
 */
var EDITOR_CLASS = 'jp-InputArea-editor';
/**
 * The class name added to the cell when collapsed.
 */
var COLLAPSED_CLASS = 'jp-mod-collapsed';
/**
 * The class name added to the cell when readonly.
 */
var READONLY_CLASS = 'jp-mod-readOnly';
/**
 * The class name added to code cells.
 */
var CODE_CELL_CLASS = 'jp-CodeCell';
/**
 * The class name added to markdown cells.
 */
var MARKDOWN_CELL_CLASS = 'jp-MarkdownCell';
/**
 * The class name added to rendered markdown output widgets.
 */
var MARKDOWN_OUTPUT_CLASS = 'jp-MarkdownOutput';
/**
 * The class name added to raw cells.
 */
var RAW_CELL_CLASS = 'jp-RawCell';
/**
 * The class name added to a rendered input area.
 */
var RENDERED_CLASS = 'jp-mod-rendered';
/**
 * The text applied to an empty markdown cell.
 */
var DEFAULT_MARKDOWN_TEXT = 'Type Markdown and LaTeX: $ Î±^2 $';
/**
 * A base cell widget.
 */
var BaseCellWidget = (function (_super) {
    __extends(BaseCellWidget, _super);
    /**
     * Construct a new base cell widget.
     */
    function BaseCellWidget(options) {
        _super.call(this);
        this._input = null;
        this._editor = null;
        this._model = null;
        this._mimetype = 'text/plain';
        this._readOnly = false;
        this._trustedCursor = null;
        this._trusted = false;
        this.addClass(CELL_CLASS);
        this.layout = new panel_1.PanelLayout();
        var renderer = options.renderer;
        this._editor = renderer.createCellEditor();
        this._input = renderer.createInputArea(this._editor);
        this.layout.addWidget(this._input);
    }
    Object.defineProperty(BaseCellWidget.prototype, "model", {
        /**
         * The model used by the widget.
         */
        get: function () {
            return this._model;
        },
        set: function (newValue) {
            if (!newValue && !this._model || newValue === this._model) {
                return;
            }
            var oldValue = this._model;
            this._model = newValue;
            // Trigger private, protected, and public updates.
            this._onModelChanged(oldValue, newValue);
            this.onModelChanged(oldValue, newValue);
            this.modelChanged.emit(void 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseCellWidget.prototype, "promptNode", {
        /**
         * Get the prompt node used by the cell.
         */
        get: function () {
            return this._input.promptNode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseCellWidget.prototype, "editor", {
        /**
         * Get the editor widget used by the cell.
         *
         * #### Notes
         * This is a ready-only property.
         */
        get: function () {
            return this._editor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseCellWidget.prototype, "mimetype", {
        /**
         * The mimetype used by the cell.
         */
        get: function () {
            return this._mimetype;
        },
        set: function (value) {
            if (!value) {
                return;
            }
            if (this._mimetype === value) {
                return;
            }
            this._mimetype = value;
            this.editor.setMimeType(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseCellWidget.prototype, "readOnly", {
        /**
         * The read only state of the cell.
         */
        get: function () {
            return this._readOnly;
        },
        set: function (value) {
            if (value === this._readOnly) {
                return;
            }
            this._readOnly = value;
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseCellWidget.prototype, "trusted", {
        /**
         * The trusted state of the cell.
         */
        get: function () {
            return this._trusted;
        },
        set: function (value) {
            if (!this._model) {
                return;
            }
            this._trustedCursor.setValue(value);
            this._trusted = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set the prompt for the widget.
     */
    BaseCellWidget.prototype.setPrompt = function (value) {
        this._input.setPrompt(value);
    };
    /**
     * Dispose of the resources held by the widget.
     */
    BaseCellWidget.prototype.dispose = function () {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        this._model = null;
        this._input = null;
        this._editor = null;
        this._trustedCursor = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle `after-attach` messages.
     */
    BaseCellWidget.prototype.onAfterAttach = function (msg) {
        this.update();
    };
    /**
     * Handle `'activate-request'` messages.
     */
    BaseCellWidget.prototype.onActivateRequest = function (msg) {
        this._editor.activate();
    };
    /**
     * Handle `update-request` messages.
     */
    BaseCellWidget.prototype.onUpdateRequest = function (msg) {
        if (!this._model) {
            return;
        }
        // Handle read only state.
        this._editor.setReadOnly(this._readOnly);
        this.toggleClass(READONLY_CLASS, this._readOnly);
    };
    /**
     * Handle changes in the model.
     *
     * #### Notes
     * Subclasses may reimplement this method as needed.
     */
    BaseCellWidget.prototype.onModelStateChanged = function (model, args) {
        // no-op
    };
    /**
     * Handle changes in the model.
     */
    BaseCellWidget.prototype.onMetadataChanged = function (model, args) {
        switch (args.name) {
            case 'trusted':
                this._trusted = !!this._trustedCursor.getValue();
                this.update();
                break;
            default:
                break;
        }
    };
    /**
     * Handle a new model.
     *
     * #### Notes
     * This method is called after the model change has been handled
     * internally and before the `modelChanged` signal is emitted.
     * The default implementation is a no-op.
     */
    BaseCellWidget.prototype.onModelChanged = function (oldValue, newValue) {
        // no-op
    };
    /**
     * Render an input instead of the text editor.
     */
    BaseCellWidget.prototype.renderInput = function (widget) {
        this.addClass(RENDERED_CLASS);
        this._input.renderInput(widget);
    };
    /**
     * Show the text editor.
     */
    BaseCellWidget.prototype.showEditor = function () {
        this.removeClass(RENDERED_CLASS);
        this._input.showEditor();
    };
    /**
     * Handle a model change.
     */
    BaseCellWidget.prototype._onModelChanged = function (oldValue, newValue) {
        // If the model is being replaced, disconnect the old signal handler.
        if (oldValue) {
            oldValue.stateChanged.disconnect(this.onModelStateChanged, this);
            oldValue.metadataChanged.disconnect(this.onMetadataChanged, this);
        }
        // Reset the editor model and set its mode to be the default MIME type.
        this._editor.model = this._model;
        this._editor.setMimeType(this._mimetype);
        // Handle trusted cursor.
        this._trustedCursor = this._model.getMetadata('trusted');
        this._trusted = !!this._trustedCursor.getValue();
        // Connect signal handlers.
        this._model.metadataChanged.connect(this.onMetadataChanged, this);
        this._model.stateChanged.connect(this.onModelStateChanged, this);
    };
    return BaseCellWidget;
}(widget_1.Widget));
exports.BaseCellWidget = BaseCellWidget;
// Define the signals for the `BaseCellWidget` class.
signaling_1.defineSignal(BaseCellWidget.prototype, 'modelChanged');
/**
 * The namespace for the `BaseCellWidget` class statics.
 */
var BaseCellWidget;
(function (BaseCellWidget) {
    /**
     * The default implementation of an `IRenderer`.
     */
    var Renderer = (function () {
        function Renderer() {
        }
        /**
         * Create a new input area for the widget.
         */
        Renderer.prototype.createInputArea = function (editor) {
            return new InputAreaWidget(editor);
        };
        return Renderer;
    }());
    BaseCellWidget.Renderer = Renderer;
})(BaseCellWidget = exports.BaseCellWidget || (exports.BaseCellWidget = {}));
/**
 * A widget for a code cell.
 */
var CodeCellWidget = (function (_super) {
    __extends(CodeCellWidget, _super);
    /**
     * Construct a code cell widget.
     */
    function CodeCellWidget(options) {
        _super.call(this, options);
        this._rendermime = null;
        this._output = null;
        this._collapsedCursor = null;
        this._scrolledCursor = null;
        this.addClass(CODE_CELL_CLASS);
        this._rendermime = options.rendermime;
        this._renderer = options.renderer;
    }
    /**
     * Dispose of the resources used by the widget.
     */
    CodeCellWidget.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._collapsedCursor = null;
        this._scrolledCursor = null;
        this._output = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Execute the cell given a kernel.
     */
    CodeCellWidget.prototype.execute = function (kernel) {
        var _this = this;
        var model = this.model;
        var code = model.source;
        if (!code.trim()) {
            model.executionCount = null;
            model.outputs.clear();
            return Promise.resolve(null);
        }
        model.executionCount = null;
        this.setPrompt('*');
        this.trusted = true;
        var outputs = model.outputs;
        return outputs.execute(code, kernel).then(function (reply) {
            var status = reply.content.status;
            if (status === 'abort') {
                model.executionCount = null;
                _this.setPrompt(' ');
            }
            else {
                model.executionCount = reply.content.execution_count;
            }
            return reply;
        });
    };
    /**
     * Handle `update-request` messages.
     */
    CodeCellWidget.prototype.onUpdateRequest = function (msg) {
        if (this._collapsedCursor) {
            var value = this._collapsedCursor.getValue();
            this.toggleClass(COLLAPSED_CLASS, value);
        }
        if (this._output) {
            // TODO: handle scrolled state.
            this._output.trusted = this.trusted;
        }
        _super.prototype.onUpdateRequest.call(this, msg);
    };
    /**
     * Handle the widget receiving a new model.
     */
    CodeCellWidget.prototype.onModelChanged = function (oldValue, newValue) {
        var model = newValue;
        var renderer = this._renderer;
        if (!this._output) {
            this._output = renderer.createOutputArea(this._rendermime);
            this.layout.addWidget(this._output);
        }
        this._output.model = model.outputs;
        this._output.trusted = this.trusted;
        this._collapsedCursor = model.getMetadata('collapsed');
        this._scrolledCursor = model.getMetadata('scrolled');
        this.setPrompt("" + (model.executionCount || ''));
    };
    /**
     * Handle changes in the model.
     */
    CodeCellWidget.prototype.onModelStateChanged = function (model, args) {
        switch (args.name) {
            case 'executionCount':
                this.setPrompt("" + model.executionCount);
                break;
            default:
                break;
        }
        _super.prototype.onModelStateChanged.call(this, model, args);
    };
    /**
     * Handle changes in the metadata.
     */
    CodeCellWidget.prototype.onMetadataChanged = function (model, args) {
        switch (args.name) {
            case 'collapsed':
            case 'scrolled':
                this.update();
                break;
            default:
                break;
        }
        _super.prototype.onMetadataChanged.call(this, model, args);
    };
    return CodeCellWidget;
}(BaseCellWidget));
exports.CodeCellWidget = CodeCellWidget;
/**
 * The namespace for the `CodeCellWidget` class statics.
 */
var CodeCellWidget;
(function (CodeCellWidget) {
    /**
     * The default implementation of an `IRenderer`.
     */
    var Renderer = (function (_super) {
        __extends(Renderer, _super);
        function Renderer() {
            _super.apply(this, arguments);
        }
        /**
         * Create an output area widget.
         */
        Renderer.prototype.createOutputArea = function (rendermime) {
            return new output_area_1.OutputAreaWidget({ rendermime: rendermime });
        };
        return Renderer;
    }(BaseCellWidget.Renderer));
    CodeCellWidget.Renderer = Renderer;
})(CodeCellWidget = exports.CodeCellWidget || (exports.CodeCellWidget = {}));
/**
 * A widget for a Markdown cell.
 *
 * #### Notes
 * Things get complicated if we want the rendered text to update
 * any time the text changes, the text editor model changes,
 * or the input area model changes.  We don't support automatically
 * updating the rendered text in all of these cases.
 */
var MarkdownCellWidget = (function (_super) {
    __extends(MarkdownCellWidget, _super);
    /**
     * Construct a Markdown cell widget.
     */
    function MarkdownCellWidget(options) {
        _super.call(this, options);
        this._rendermime = null;
        this._output = null;
        this._rendered = true;
        this._prev = '';
        this.addClass(MARKDOWN_CELL_CLASS);
        // Insist on the Github-flavored markdown mode.
        this.mimetype = 'text/x-ipythongfm';
        this._rendermime = options.rendermime;
    }
    Object.defineProperty(MarkdownCellWidget.prototype, "rendered", {
        /**
         * Whether the cell is rendered.
         */
        get: function () {
            return this._rendered;
        },
        set: function (value) {
            if (value === this._rendered) {
                return;
            }
            this._rendered = value;
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resource held by the widget.
     */
    MarkdownCellWidget.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._output = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle `update-request` messages.
     */
    MarkdownCellWidget.prototype.onUpdateRequest = function (msg) {
        var model = this.model;
        if (this.rendered) {
            var text = model && model.source || DEFAULT_MARKDOWN_TEXT;
            // Do not re-render if the text has not changed.
            if (text !== this._prev) {
                var bundle = { 'text/markdown': text };
                var trusted = this.trusted;
                var widget = this._rendermime.render({ bundle: bundle, trusted: trusted });
                this._output = widget || new widget_1.Widget();
                this._output.addClass(MARKDOWN_OUTPUT_CLASS);
                this.update();
            }
            else {
                this._output.show();
            }
            this._prev = text;
            this.renderInput(this._output);
        }
        else {
            this.showEditor();
        }
        _super.prototype.onUpdateRequest.call(this, msg);
    };
    return MarkdownCellWidget;
}(BaseCellWidget));
exports.MarkdownCellWidget = MarkdownCellWidget;
/**
 * A widget for a raw cell.
 */
var RawCellWidget = (function (_super) {
    __extends(RawCellWidget, _super);
    /**
     * Construct a raw cell widget.
     */
    function RawCellWidget(options) {
        _super.call(this, options);
        this.addClass(RAW_CELL_CLASS);
    }
    return RawCellWidget;
}(BaseCellWidget));
exports.RawCellWidget = RawCellWidget;
/**
 * An input area widget, which hosts a prompt and an editor widget.
 */
var InputAreaWidget = (function (_super) {
    __extends(InputAreaWidget, _super);
    /**
     * Construct an input area widget.
     */
    function InputAreaWidget(editor) {
        _super.call(this);
        this.addClass(INPUT_CLASS);
        editor.addClass(EDITOR_CLASS);
        this.layout = new panel_1.PanelLayout();
        this._editor = editor;
        var prompt = this._prompt = new widget_1.Widget();
        prompt.addClass(PROMPT_CLASS);
        var layout = this.layout;
        layout.addWidget(prompt);
        layout.addWidget(editor);
    }
    Object.defineProperty(InputAreaWidget.prototype, "promptNode", {
        /**
         * Get the prompt node used by the cell.
         */
        get: function () {
            return this._prompt.node;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Render an input instead of the text editor.
     */
    InputAreaWidget.prototype.renderInput = function (widget) {
        this._editor.hide();
        var layout = this.layout;
        if (this._rendered) {
            layout.removeWidget(this._rendered);
        }
        this._rendered = widget;
        widget.show();
        layout.addWidget(widget);
    };
    /**
     * Show the text editor.
     */
    InputAreaWidget.prototype.showEditor = function () {
        this._editor.show();
        var layout = this.layout;
        if (this._rendered) {
            layout.removeWidget(this._rendered);
        }
    };
    /**
     * Set the prompt of the input area.
     */
    InputAreaWidget.prototype.setPrompt = function (value) {
        if (value === 'null') {
            value = ' ';
        }
        var text = "In [" + (value || ' ') + "]:";
        this._prompt.node.textContent = text;
    };
    return InputAreaWidget;
}(widget_1.Widget));
exports.InputAreaWidget = InputAreaWidget;
//# sourceMappingURL=widget.js.map