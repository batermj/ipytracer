// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var disposable_1 = require('phosphor/lib/core/disposable');
var signaling_1 = require('phosphor/lib/core/signaling');
var token_1 = require('phosphor/lib/core/token');
var instancetracker_1 = require('../common/instancetracker');
/* tslint:disable */
/**
 * The notebook tracker token.
 */
exports.INotebookTracker = new token_1.Token('jupyter.services.notebooks');
/* tslint:enable */
var NotebookTracker = (function (_super) {
    __extends(NotebookTracker, _super);
    function NotebookTracker() {
        _super.apply(this, arguments);
        this._activeCell = null;
        this._handler = null;
    }
    Object.defineProperty(NotebookTracker.prototype, "activeCell", {
        /**
         * The currently focused cell.
         *
         * #### Notes
         * This is a read-only property. If there is no cell with the focus, then this
         * value is `null`.
         */
        get: function () {
            var widget = this.currentWidget;
            if (!widget) {
                return null;
            }
            return widget.content.activeCell || null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the tracker.
     */
    NotebookTracker.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        if (this._handler) {
            this._handler.dispose();
            this._handler = null;
        }
        this._activeCell = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle the current change event.
     */
    NotebookTracker.prototype.onCurrentChanged = function () {
        var _this = this;
        // Store an internal reference to active cell to prevent false positives.
        var activeCell = this.activeCell;
        if (activeCell && activeCell === this._activeCell) {
            return;
        }
        this._activeCell = activeCell;
        if (this._handler) {
            this._handler.dispose();
        }
        var widget = this.currentWidget;
        if (!widget) {
            return;
        }
        // Create a signal handler for cell changes.
        var changeHandler = function (sender, cell) {
            _this.activeCellChanged.emit(cell || null);
        };
        // Connect the signal handler to the current notebook panel.
        widget.content.activeCellChanged.connect(changeHandler);
        this._handler = new disposable_1.DisposableDelegate(function () {
            // Only disconnect if the widget still exists.
            if (!widget.isDisposed) {
                widget.content.activeCellChanged.disconnect(changeHandler);
            }
        });
        // Since the notebook has changed, immediately signal an active cell change.
        this.activeCellChanged.emit(widget.content.activeCell || null);
    };
    return NotebookTracker;
}(instancetracker_1.InstanceTracker));
exports.NotebookTracker = NotebookTracker;
// Define the signals for the `NotebookTracker` class.
signaling_1.defineSignal(instancetracker_1.InstanceTracker.prototype, 'activeCellChanged');
//# sourceMappingURL=tracker.js.map