// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var signaling_1 = require('phosphor/lib/core/signaling');
var CodeMirror = require('codemirror');
var codemirror_1 = require('../../../codemirror');
var widget_1 = require('../../../codemirror/widget');
/**
 * The key code for the up arrow key.
 */
var UP_ARROW = 38;
/**
 * The key code for the down arrow key.
 */
var DOWN_ARROW = 40;
/**
 * The key code for the tab key.
 */
var TAB = 9;
/**
 * The class name added to cell editor widget nodes.
 */
var CELL_EDITOR_CLASS = 'jp-CellEditor';
/**
 * The class name added to read only cell editor widgets.
 */
var READ_ONLY_CLASS = 'jp-mod-readOnly';
/**
 * A code mirror widget for a cell editor.
 */
var CodeMirrorCellEditorWidget = (function (_super) {
    __extends(CodeMirrorCellEditorWidget, _super);
    /**
     * Construct a new cell editor widget.
     */
    function CodeMirrorCellEditorWidget(options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        _super.call(this, options);
        this._model = null;
        this.addClass(CELL_EDITOR_CLASS);
        CodeMirror.on(this.editor.getDoc(), 'change', function (instance, change) {
            _this.onDocChange(instance, change);
        });
        CodeMirror.on(this.editor, 'keydown', function (instance, evt) {
            _this.onEditorKeydown(instance, evt);
        });
    }
    Object.defineProperty(CodeMirrorCellEditorWidget.prototype, "model", {
        /**
         * The cell model used by the editor.
         */
        get: function () {
            return this._model;
        },
        set: function (model) {
            if (!model && !this._model || model === this._model) {
                return;
            }
            var doc = this.editor.getDoc();
            // If the model is being replaced, disconnect the old signal handler.
            if (this._model) {
                this._model.stateChanged.disconnect(this.onModelStateChanged, this);
            }
            if (!model) {
                doc.setValue('');
                this._model = null;
                return;
            }
            this._model = model;
            doc.setValue(this._model.source || '');
            doc.clearHistory();
            this._model.stateChanged.connect(this.onModelStateChanged, this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeMirrorCellEditorWidget.prototype, "lineNumbers", {
        /**
         * The line numbers state of the editor.
         */
        get: function () {
            return this.editor.getOption('lineNumbers');
        },
        set: function (value) {
            this.editor.setOption('lineNumbers', value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the editor.
     */
    CodeMirrorCellEditorWidget.prototype.dispose = function () {
        this._model = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Change the mode for an editor based on the given mime type.
     */
    CodeMirrorCellEditorWidget.prototype.setMimeType = function (mimeType) {
        codemirror_1.loadModeByMIME(this.editor, mimeType);
    };
    /**
     * Set whether the editor is read only.
     */
    CodeMirrorCellEditorWidget.prototype.setReadOnly = function (readOnly) {
        var option = readOnly ? true : false;
        this.editor.setOption('readOnly', option);
        this.toggleClass(READ_ONLY_CLASS, option);
    };
    /**
     * Test whether the editor has keyboard focus.
     */
    CodeMirrorCellEditorWidget.prototype.hasFocus = function () {
        return this.editor.hasFocus();
    };
    /**
     * Returns a zero-based last line number.
     */
    CodeMirrorCellEditorWidget.prototype.getLastLine = function () {
        return this.editor.getDoc().lastLine();
    };
    /**
     * Get the current cursor position of the editor.
     */
    CodeMirrorCellEditorWidget.prototype.getCursorPosition = function () {
        var doc = this.editor.getDoc();
        var position = doc.getCursor();
        return doc.indexFromPos(position);
    };
    /**
     * Set the position of the cursor.
     *
     * @param position - A new cursor's position.
     */
    CodeMirrorCellEditorWidget.prototype.setCursorPosition = function (position) {
        var doc = this.editor.getDoc();
        doc.setCursor(doc.posFromIndex(position));
    };
    /**
     * Set the position of the cursor.
     *
     * @param line - A zero-based line number.
     *
     * @param character - A zero-based character number.
     */
    CodeMirrorCellEditorWidget.prototype.setCursor = function (line, character) {
        var doc = this.editor.getDoc();
        doc.setCursor({
            line: line,
            ch: character
        });
    };
    /**
     * Handle changes in the model state.
     */
    CodeMirrorCellEditorWidget.prototype.onModelStateChanged = function (model, args) {
        switch (args.name) {
            case 'source':
                var doc = this.editor.getDoc();
                if (doc.getValue() !== args.newValue) {
                    doc.setValue(args.newValue);
                }
                break;
            default:
                break;
        }
    };
    /**
     * Handle change events from the document.
     */
    CodeMirrorCellEditorWidget.prototype.onDocChange = function (doc, change) {
        var model = this.model;
        var editor = this.editor;
        var oldValue = model.source;
        var newValue = doc.getValue();
        var cursor = doc.getCursor();
        var line = cursor.line;
        var ch = cursor.ch;
        var chHeight = editor.defaultTextHeight();
        var chWidth = editor.defaultCharWidth();
        var coords = editor.charCoords({ line: line, ch: ch }, 'page');
        var position = editor.getDoc().indexFromPos({ line: line, ch: ch });
        model.source = newValue;
        this.textChanged.emit({
            line: line, ch: ch, chHeight: chHeight, chWidth: chWidth, coords: coords, position: position, oldValue: oldValue, newValue: newValue
        });
    };
    /**
     * Handle keydown events from the editor.
     */
    CodeMirrorCellEditorWidget.prototype.onEditorKeydown = function (editor, event) {
        var doc = editor.getDoc();
        var cursor = doc.getCursor();
        var line = cursor.line;
        var ch = cursor.ch;
        if (event.keyCode === TAB) {
            // If the tab is modified, ignore it.
            if (event.ctrlKey || event.shiftKey || event.altKey || event.metaKey) {
                return;
            }
            return this.onTabEvent(event, ch, line);
        }
        if (line === 0 && ch === 0 && event.keyCode === UP_ARROW) {
            if (!event.shiftKey) {
                this.edgeRequested.emit('top');
            }
            return;
        }
        var lastLine = doc.lastLine();
        var lastCh = doc.getLineHandle(lastLine).text.length;
        if (line === lastLine && ch === lastCh && event.keyCode === DOWN_ARROW) {
            if (!event.shiftKey) {
                this.edgeRequested.emit('bottom');
            }
            return;
        }
    };
    /**
     * Handle a tab key press.
     */
    CodeMirrorCellEditorWidget.prototype.onTabEvent = function (event, ch, line) {
        var editor = this.editor;
        var doc = editor.getDoc();
        // If there is a text selection, no completion requests should be emitted.
        if (doc.getSelection()) {
            return;
        }
        var currentValue = doc.getValue();
        var currentLine = currentValue.split('\n')[line];
        var chHeight = editor.defaultTextHeight();
        var chWidth = editor.defaultCharWidth();
        var coords = editor.charCoords({ line: line, ch: ch }, 'page');
        var position = editor.getDoc().indexFromPos({ line: line, ch: ch });
        // A completion request signal should only be emitted if the current
        // character or a preceding character is not whitespace.
        //
        // Otherwise, the default tab action of creating a tab character should be
        // allowed to propagate.
        if (!currentLine.substring(0, ch).match(/\S/)) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        var data = {
            line: line, ch: ch, chHeight: chHeight, chWidth: chWidth, coords: coords, position: position, currentValue: currentValue
        };
        this.completionRequested.emit(data);
    };
    return CodeMirrorCellEditorWidget;
}(widget_1.CodeMirrorWidget));
exports.CodeMirrorCellEditorWidget = CodeMirrorCellEditorWidget;
// Define the signals for the `CodeMirrorCellEditorWidget` class.
signaling_1.defineSignal(CodeMirrorCellEditorWidget.prototype, 'completionRequested');
signaling_1.defineSignal(CodeMirrorCellEditorWidget.prototype, 'edgeRequested');
signaling_1.defineSignal(CodeMirrorCellEditorWidget.prototype, 'textChanged');
//# sourceMappingURL=editor.js.map