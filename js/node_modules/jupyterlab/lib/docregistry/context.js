// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var services_1 = require('@jupyterlab/services');
var searching_1 = require('phosphor/lib/algorithm/searching');
var disposable_1 = require('phosphor/lib/core/disposable');
var signaling_1 = require('phosphor/lib/core/signaling');
var docregistry_1 = require('../docregistry');
var dialog_1 = require('../dialog');
/**
 * An implementation of a document context.
 *
 * This class is typically instantiated by the document manger.
 */
var Context = (function () {
    /**
     * Construct a new document context.
     */
    function Context(options) {
        var _this = this;
        this._manager = null;
        this._opener = null;
        this._model = null;
        this._path = '';
        this._session = null;
        this._factory = null;
        this._contentsModel = null;
        this._populatedPromise = new services_1.utils.PromiseDelegate();
        this._isPopulated = false;
        this._isReady = false;
        var manager = this._manager = options.manager;
        this._factory = options.factory;
        this._opener = options.opener;
        this._path = options.path;
        var ext = services_1.ContentsManager.extname(this._path);
        var lang = this._factory.preferredLanguage(ext);
        this._model = this._factory.createNew(lang);
        manager.sessions.runningChanged.connect(this._onSessionsChanged, this);
        manager.contents.fileChanged.connect(this._onFileChanged, this);
        this._readyPromise = manager.ready.then(function () {
            return _this._populatedPromise.promise;
        });
    }
    Object.defineProperty(Context.prototype, "model", {
        /**
         * Get the model associated with the document.
         */
        get: function () {
            return this._model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "kernel", {
        /**
         * The current kernel associated with the document.
         */
        get: function () {
            return this._session ? this._session.kernel : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "path", {
        /**
         * The current path associated with the document.
         */
        get: function () {
            return this._path;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "contentsModel", {
        /**
         * The current contents model associated with the document
         *
         * #### Notes
         * The model will have an  empty `contents` field.
         */
        get: function () {
            return this._contentsModel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "factoryName", {
        /**
         * Get the model factory name.
         *
         * #### Notes
         * This is not part of the `IContext` API.
         */
        get: function () {
            return this.isDisposed ? '' : this._factory.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "isDisposed", {
        /**
         * Test whether the context has been disposed (read-only).
         */
        get: function () {
            return this._manager === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the context.
     */
    Context.prototype.dispose = function () {
        var _this = this;
        if (this.isDisposed) {
            return;
        }
        this.disposed.emit(void 0);
        signaling_1.clearSignalData(this);
        this._model.dispose();
        this._manager = null;
        this._factory = null;
        if (this._session) {
            this._session.shutdown().then(function () {
                _this._session.dispose();
                _this._session = null;
            });
        }
    };
    Object.defineProperty(Context.prototype, "specs", {
        /**
         * The kernel spec models
         */
        get: function () {
            return this._manager.specs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "isReady", {
        /**
         * Whether the context is ready.
         */
        get: function () {
            return this._isReady;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "ready", {
        /**
         * A promise that is fulfilled when the context is ready.
         */
        get: function () {
            return this._readyPromise;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Start the default kernel for the context.
     *
     * @returns A promise that resolves with the new kernel.
     */
    Context.prototype.startDefaultKernel = function () {
        var _this = this;
        return this.ready.then(function () {
            var model = _this.model;
            var name = docregistry_1.findKernel(model.defaultKernelName, model.defaultKernelLanguage, _this._manager.specs);
            return _this.changeKernel({ name: name });
        });
    };
    /**
     * Change the current kernel associated with the document.
     */
    Context.prototype.changeKernel = function (options) {
        var _this = this;
        var session = this._session;
        if (options) {
            if (session) {
                return session.changeKernel(options);
            }
            else {
                var path = this._path;
                var sOptions = {
                    path: path,
                    kernelName: options.name,
                    kernelId: options.id
                };
                return this._startSession(sOptions);
            }
        }
        else {
            if (session) {
                this._session = null;
                return session.shutdown().then(function () {
                    session.dispose();
                    _this.kernelChanged.emit(null);
                    return void 0;
                });
            }
            else {
                return Promise.resolve(void 0);
            }
        }
    };
    /**
     * Save the document contents to disk.
     */
    Context.prototype.save = function () {
        var _this = this;
        var model = this._model;
        var path = this._path;
        if (model.readOnly) {
            return Promise.reject(new Error('Read only'));
        }
        var content;
        if (this._factory.fileFormat === 'json') {
            content = model.toJSON();
        }
        else {
            content = model.toString();
        }
        var options = {
            type: this._factory.contentType,
            format: this._factory.fileFormat,
            content: content
        };
        var promise = this._manager.contents.save(path, options);
        return promise.then(function (value) {
            model.dirty = false;
            _this._updateContentsModel(value);
            if (!_this._isPopulated) {
                return _this._populate();
            }
        }).catch(function (err) {
            dialog_1.showDialog({
                title: 'File Save Error',
                body: err.xhr.responseText,
                buttons: [dialog_1.okButton]
            });
        });
    };
    /**
     * Save the document to a different path chosen by the user.
     */
    Context.prototype.saveAs = function () {
        var _this = this;
        return Private.getSavePath(this._path).then(function (newPath) {
            if (!newPath) {
                return;
            }
            _this._path = newPath;
            var session = _this._session;
            if (session) {
                var options = {
                    path: newPath,
                    kernelId: session.kernel.id,
                    kernelName: session.kernel.name
                };
                return _this._startSession(options).then(function () {
                    return _this.save();
                });
            }
            return _this.save();
        });
    };
    /**
     * Revert the document contents to disk contents.
     */
    Context.prototype.revert = function () {
        var _this = this;
        var opts = {
            format: this._factory.fileFormat,
            type: this._factory.contentType,
            content: true
        };
        var path = this._path;
        var model = this._model;
        return this._manager.contents.get(path, opts).then(function (contents) {
            if (contents.format === 'json') {
                model.fromJSON(contents.content);
            }
            else {
                model.fromString(contents.content);
            }
            _this._updateContentsModel(contents);
            model.dirty = false;
            if (!_this._isPopulated) {
                return _this._populate();
            }
        }).catch(function (err) {
            dialog_1.showDialog({
                title: 'File Load Error',
                body: err.xhr.responseText,
                buttons: [dialog_1.okButton]
            });
        });
    };
    /**
     * Create a checkpoint for the file.
     */
    Context.prototype.createCheckpoint = function () {
        return this._manager.contents.createCheckpoint(this._path);
    };
    /**
     * Delete a checkpoint for the file.
     */
    Context.prototype.deleteCheckpoint = function (checkpointId) {
        return this._manager.contents.deleteCheckpoint(this._path, checkpointId);
    };
    /**
     * Restore the file to a known checkpoint state.
     */
    Context.prototype.restoreCheckpoint = function (checkpointId) {
        var contents = this._manager.contents;
        var path = this._path;
        if (checkpointId) {
            return contents.restoreCheckpoint(path, checkpointId);
        }
        return this.listCheckpoints().then(function (checkpoints) {
            if (!checkpoints.length) {
                return;
            }
            checkpointId = checkpoints[checkpoints.length - 1].id;
            return contents.restoreCheckpoint(path, checkpointId);
        });
    };
    /**
     * List available checkpoints for a file.
     */
    Context.prototype.listCheckpoints = function () {
        return this._manager.contents.listCheckpoints(this._path);
    };
    /**
     * Resolve a relative url to a correct server path.
     */
    Context.prototype.resolveUrl = function (url) {
        // Ignore urls that have a protocol.
        if (services_1.utils.urlParse(url).protocol || url.indexOf('//') === 0) {
            return url;
        }
        var cwd = services_1.ContentsManager.dirname(this._path);
        var path = services_1.ContentsManager.getAbsolutePath(url, cwd);
        return this._manager.contents.getDownloadUrl(path);
    };
    /**
     * Add a sibling widget to the document manager.
     */
    Context.prototype.addSibling = function (widget) {
        var opener = this._opener;
        if (opener) {
            opener(widget);
        }
        return new disposable_1.DisposableDelegate(function () {
            widget.close();
        });
    };
    /**
     * Handle a change on the contents manager.
     */
    Context.prototype._onFileChanged = function (sender, change) {
        if (change.type !== 'rename') {
            return;
        }
        if (change.oldValue.path === this._path) {
            var path = this._path = change.newValue.path;
            if (this._session) {
                this._session.rename(path);
            }
            this.pathChanged.emit(path);
        }
    };
    /**
     * Start a session and set up its signals.
     */
    Context.prototype._startSession = function (options) {
        var _this = this;
        return this._manager.sessions.startNew(options).then(function (session) {
            if (_this._session) {
                _this._session.dispose();
            }
            _this._session = session;
            _this.kernelChanged.emit(session.kernel);
            session.pathChanged.connect(function (s, path) {
                if (path !== _this._path) {
                    _this._path = path;
                    _this.pathChanged.emit(path);
                }
            });
            session.kernelChanged.connect(function (s, kernel) {
                _this.kernelChanged.emit(kernel);
            });
            return session.kernel;
        }).catch(function (err) {
            var response = JSON.parse(err.xhr.response);
            var body = document.createElement('pre');
            body.textContent = response['traceback'];
            dialog_1.showDialog({
                title: 'Error Starting Kernel',
                body: body,
                buttons: [dialog_1.okButton]
            });
            return Promise.reject(err);
        });
    };
    /**
     * Update our contents model, without the content.
     */
    Context.prototype._updateContentsModel = function (model) {
        var newModel = {
            path: model.path,
            name: model.name,
            type: model.type,
            writable: model.writable,
            created: model.created,
            last_modified: model.last_modified,
            mimetype: model.mimetype,
            format: model.format
        };
        var mod = this._contentsModel ? this._contentsModel.last_modified : null;
        this._contentsModel = newModel;
        if (!mod || newModel.last_modified !== mod) {
            this.fileChanged.emit(newModel);
        }
    };
    /**
     * Handle a change to the running sessions.
     */
    Context.prototype._onSessionsChanged = function (sender, models) {
        var session = this._session;
        if (!session) {
            return;
        }
        var index = searching_1.findIndex(models, function (model) { return model.id === session.id; });
        if (index === -1) {
            session.dispose();
            this._session = null;
            this.kernelChanged.emit(null);
        }
    };
    /**
     * Handle an initial population.
     */
    Context.prototype._populate = function () {
        var _this = this;
        this._isPopulated = true;
        // Add a checkpoint if none exists.
        return this.listCheckpoints().then(function (checkpoints) {
            if (!checkpoints) {
                return _this.createCheckpoint();
            }
        }).then(function () {
            _this._isReady = true;
            _this._populatedPromise.resolve(void 0);
        });
    };
    return Context;
}());
exports.Context = Context;
// Define the signals for the `Context` class.
signaling_1.defineSignal(Context.prototype, 'kernelChanged');
signaling_1.defineSignal(Context.prototype, 'pathChanged');
signaling_1.defineSignal(Context.prototype, 'fileChanged');
signaling_1.defineSignal(Context.prototype, 'disposed');
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * Get a new file path from the user.
     */
    function getSavePath(path) {
        var input = document.createElement('input');
        input.value = path;
        return dialog_1.showDialog({
            title: 'Save File As..',
            body: input,
            okText: 'SAVE'
        }).then(function (result) {
            if (result.text === 'SAVE') {
                return input.value;
            }
        });
    }
    Private.getSavePath = getSavePath;
})(Private || (Private = {}));
//# sourceMappingURL=context.js.map