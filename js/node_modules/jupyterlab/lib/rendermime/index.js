// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var searching_1 = require('phosphor/lib/algorithm/searching');
var vector_1 = require('phosphor/lib/collections/vector');
var token_1 = require('phosphor/lib/core/token');
/* tslint:disable */
/**
 * The rendermime token.
 */
exports.IRenderMime = new token_1.Token('jupyter.services.rendermime');
/**
 * A composite renderer.
 *
 * #### Notes
 * When rendering a mimebundle, a mimetype is selected from the mimetypes by
 * searching through the `this.order` list. The first mimetype found in the
 * bundle determines the renderer that will be used.
 *
 * You can add a renderer by adding it to the `renderers` object and
 * registering the mimetype in the `order` array.
 *
 * Untrusted bundles are handled differently from trusted ones.  Untrusted
 * bundles will only render outputs that can be rendered "safely"
 * (see [[RenderMime.IRenderer.isSafe]]) or can be "sanitized"
 * (see [[RenderMime.IRenderer.isSanitizable]]).
 */
var RenderMime = (function () {
    /**
     * Construct a renderer.
     */
    function RenderMime(options) {
        this._renderers = Object.create(null);
        this._sanitizer = null;
        for (var mime in options.renderers) {
            this._renderers[mime] = options.renderers[mime];
        }
        this._order = new vector_1.Vector(options.order);
        this._sanitizer = options.sanitizer;
        this._resolver = options.resolver || null;
    }
    Object.defineProperty(RenderMime.prototype, "resolver", {
        /**
         * The object used to resolve relative urls for the rendermime instance.
         */
        get: function () {
            return this._resolver;
        },
        set: function (value) {
            this._resolver = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get an iterator over the ordered list of mimetypes.
     *
     * #### Notes
     * These mimetypes are searched from beginning to end, and the first matching
     * mimetype is used.
     */
    RenderMime.prototype.mimetypes = function () {
        return this._order.iter();
    };
    /**
     * Render a mimebundle.
     *
     * @param bundle - the mimebundle to render.
     *
     * @param trusted - whether the bundle is trusted.
     *
     * #### Notes
     * We select the preferred mimetype in bundle based on whether the output is
     * trusted (see [[preferredMimetype]]), and then pass a sanitizer to the
     * renderer if the output should be sanitized.
     */
    RenderMime.prototype.render = function (options) {
        var trusted = options.trusted, bundle = options.bundle, injector = options.injector;
        var mimetype = this.preferredMimetype(bundle, trusted);
        if (!mimetype) {
            return void 0;
        }
        var rendererOptions = {
            mimetype: mimetype,
            source: bundle[mimetype],
            injector: injector,
            resolver: this._resolver,
            sanitizer: trusted ? null : this._sanitizer
        };
        return this._renderers[mimetype].render(rendererOptions);
    };
    /**
     * Find the preferred mimetype in a mimebundle.
     *
     * @param bundle - the mimebundle giving available mimetype content.
     *
     * @param trusted - whether the bundle is trusted.
     *
     * #### Notes
     * For untrusted bundles, only select mimetypes that can be rendered
     * "safely"  (see [[RenderMime.IRenderer.isSafe]]) or can  be "sanitized"
     * (see [[RenderMime.IRenderer.isSanitizable]]).
     */
    RenderMime.prototype.preferredMimetype = function (bundle, trusted) {
        var _this = this;
        if (trusted === void 0) { trusted = false; }
        return searching_1.find(this._order, function (m) {
            if (m in bundle) {
                var renderer = _this._renderers[m];
                if (trusted || renderer.isSafe(m) || renderer.isSanitizable(m)) {
                    return true;
                }
            }
        });
    };
    /**
     * Clone the rendermime instance with shallow copies of data.
     */
    RenderMime.prototype.clone = function () {
        return new RenderMime({
            renderers: this._renderers,
            order: this._order.iter(),
            sanitizer: this._sanitizer
        });
    };
    /**
     * Add a renderer by mimetype.
     *
     * @param mimetype - The mimetype of the renderer.
     * @param renderer - The renderer instance.
     * @param index - The optional order index.
     *
     * ####Notes
     * Negative indices count from the end, so -1 refers to the penultimate index.
     * Use the index of `.order.length` to add to the end of the render precedence list,
     * which would make the new renderer the last choice.
     */
    RenderMime.prototype.addRenderer = function (mimetype, renderer, index) {
        if (index === void 0) { index = 0; }
        this._renderers[mimetype] = renderer;
        this._order.insert(index, mimetype);
    };
    /**
     * Remove a renderer by mimetype.
     */
    RenderMime.prototype.removeRenderer = function (mimetype) {
        delete this._renderers[mimetype];
        this._order.remove(mimetype);
    };
    return RenderMime;
}());
exports.RenderMime = RenderMime;
//# sourceMappingURL=index.js.map