// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var vector_1 = require('phosphor/lib/collections/vector');
var signaling_1 = require('phosphor/lib/core/signaling');
/**
 * A console history manager object.
 */
var ConsoleHistory = (function () {
    /**
     * Construct a new console history object.
     */
    function ConsoleHistory(options) {
        this._cursor = 0;
        this._hasSession = false;
        this._history = null;
        this._kernel = null;
        this._placeholder = '';
        this._history = new vector_1.Vector();
        if (options && options.kernel) {
            this.kernel = options.kernel;
        }
    }
    Object.defineProperty(ConsoleHistory.prototype, "isDisposed", {
        /**
         * Get whether the console history manager is disposed.
         */
        get: function () {
            return this._history === null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConsoleHistory.prototype, "kernel", {
        /**
         * The current kernel supplying navigation history.
         */
        get: function () {
            return this._kernel;
        },
        set: function (newValue) {
            var _this = this;
            if (newValue === this._kernel) {
                return;
            }
            this._kernel = newValue;
            if (!this._kernel) {
                this._history = new vector_1.Vector();
                return;
            }
            this._kernel.requestHistory(Private.initialRequest).then(function (v) {
                _this.onHistory(v);
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConsoleHistory.prototype, "placeholder", {
        /**
         * The placeholder text that a history session began with.
         */
        get: function () {
            return this._placeholder;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the console history manager.
     */
    ConsoleHistory.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        signaling_1.clearSignalData(this);
        this._history = null;
    };
    /**
     * Get the previous item in the console history.
     *
     * @param placeholder - The placeholder string that gets temporarily added
     * to the history only for the duration of one history session. If multiple
     * placeholders are sent within a session, only the first one is accepted.
     *
     * @returns A Promise for console command text or `undefined` if unavailable.
     */
    ConsoleHistory.prototype.back = function (placeholder) {
        if (!this._hasSession) {
            this._hasSession = true;
            this._placeholder = placeholder;
        }
        var content = this._history.at(--this._cursor);
        this._cursor = Math.max(0, this._cursor);
        return Promise.resolve(content);
    };
    /**
     * Get the next item in the console history.
     *
     * @param placeholder - The placeholder string that gets temporarily added
     * to the history only for the duration of one history session. If multiple
     * placeholders are sent within a session, only the first one is accepted.
     *
     * @returns A Promise for console command text or `undefined` if unavailable.
     */
    ConsoleHistory.prototype.forward = function (placeholder) {
        if (!this._hasSession) {
            this._hasSession = true;
            this._placeholder = placeholder;
        }
        var content = this._history.at(++this._cursor);
        this._cursor = Math.min(this._history.length, this._cursor);
        return Promise.resolve(content);
    };
    /**
     * Add a new item to the bottom of history.
     *
     * @param item The item being added to the bottom of history.
     *
     * #### Notes
     * If the item being added is undefined or empty, it is ignored. If the item
     * being added is the same as the last item in history, it is ignored as well
     * so that the console's history will consist of no contiguous repetitions.
     */
    ConsoleHistory.prototype.push = function (item) {
        if (item && item !== this._history.back) {
            this._history.pushBack(item);
        }
        this.reset();
    };
    /**
     * Reset the history navigation state, i.e., start a new history session.
     */
    ConsoleHistory.prototype.reset = function () {
        this._cursor = this._history.length;
        this._hasSession = false;
        this._placeholder = '';
    };
    /**
     * Populate the history collection on history reply from a kernel.
     *
     * @param value The kernel message history reply.
     *
     * #### Notes
     * History entries have the shape:
     * [session: number, line: number, input: string]
     * Contiguous duplicates are stripped out of the API response.
     */
    ConsoleHistory.prototype.onHistory = function (value) {
        this._history = new vector_1.Vector();
        var last = '';
        var current = '';
        for (var i = 0; i < value.content.history.length; i++) {
            current = value.content.history[i][2];
            if (current !== last) {
                this._history.pushBack(last = current);
            }
        }
        // Reset the history navigation cursor back to the bottom.
        this._cursor = this._history.length;
    };
    return ConsoleHistory;
}());
exports.ConsoleHistory = ConsoleHistory;
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    Private.initialRequest = {
        output: false,
        raw: true,
        hist_access_type: 'tail',
        n: 500
    };
})(Private || (Private = {}));
//# sourceMappingURL=history.js.map