// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var messaging_1 = require('phosphor/lib/core/messaging');
var signaling_1 = require('phosphor/lib/core/signaling');
var token_1 = require('phosphor/lib/core/token');
var panel_1 = require('phosphor/lib/ui/panel');
var widget_1 = require('phosphor/lib/ui/widget');
var completer_1 = require('../completer');
var inspector_1 = require('../inspector');
var foreign_1 = require('./foreign');
var history_1 = require('./history');
var observablevector_1 = require('../common/observablevector');
/**
 * The class name added to console widgets.
 */
var CONSOLE_CLASS = 'jp-ConsoleContent';
/**
 * The class name added to the console banner.
 */
var BANNER_CLASS = 'jp-ConsoleContent-banner';
/**
 * The class name of a cell whose input originated from a foreign session.
 */
var FOREIGN_CELL_CLASS = 'jp-ConsoleContent-foreignCell';
/**
 * The class name of the active prompt
 */
var PROMPT_CLASS = 'jp-ConsoleContent-prompt';
/**
 * The class name of the panel that holds cell content.
 */
var CONTENT_CLASS = 'jp-ConsoleContent-content';
/**
 * The class name of the panel that holds prompts.
 */
var INPUT_CLASS = 'jp-ConsoleContent-input';
/**
 * The timeout in ms for execution requests to the kernel.
 */
var EXECUTION_TIMEOUT = 250;
/**
 * A widget containing a Jupyter console's content.
 *
 * #### Notes
 * The ConsoleContent class is intended to be used within a ConsolePanel
 * instance. Under most circumstances, it is not instantiated by user code.
 */
var ConsoleContent = (function (_super) {
    __extends(ConsoleContent, _super);
    /**
     * Construct a console content widget.
     */
    function ConsoleContent(options) {
        var _this = this;
        _super.call(this);
        this._cells = null;
        this._completer = null;
        this._completerHandler = null;
        this._content = null;
        this._foreignHandler = null;
        this._history = null;
        this._input = null;
        this._inspectionHandler = null;
        this._listening = false;
        this._mimetype = 'text/x-ipython';
        this._renderer = null;
        this._rendermime = null;
        this._session = null;
        this._setByHistory = false;
        this.addClass(CONSOLE_CLASS);
        // Create the panels that hold the content and input.
        var layout = this.layout = new panel_1.PanelLayout();
        this._cells = new observablevector_1.ObservableVector();
        this._content = new panel_1.Panel();
        this._input = new panel_1.Panel();
        this._renderer = options.renderer;
        this._rendermime = options.rendermime;
        this._session = options.session;
        this._history = options.history || new history_1.ConsoleHistory({
            kernel: this._session.kernel
        });
        // Add top-level CSS classes.
        this._content.addClass(CONTENT_CLASS);
        this._input.addClass(INPUT_CLASS);
        // Insert the content and input panes into the widget.
        layout.addWidget(this._content);
        layout.addWidget(this._input);
        // Create the banner.
        var banner = this._renderer.createBanner();
        banner.addClass(BANNER_CLASS);
        banner.readOnly = true;
        banner.model.source = '...';
        this._content.addWidget(banner);
        // Set the banner text and the mimetype.
        this._initialize();
        // Set up the inspection handler.
        this._inspectionHandler = new inspector_1.InspectionHandler({
            kernel: this._session.kernel,
            rendermime: this._rendermime
        });
        // Set up the foreign iopub handler.
        this._foreignHandler = new foreign_1.ForeignHandler({
            kernel: this._session.kernel,
            parent: this,
            renderer: { createCell: function () { return _this._newForeignCell(); } }
        });
        // Instantiate the completer.
        this._newCompleter(options.completer);
    }
    Object.defineProperty(ConsoleContent.prototype, "cells", {
        /**
         * The list of content cells in the console.
         *
         * #### Notes
         * This list does not include the banner or the prompt for a console.
         */
        get: function () {
            return this._cells;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConsoleContent.prototype, "content", {
        /*
         * The console content panel that holds the banner and executed cells.
         */
        get: function () {
            return this._content;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConsoleContent.prototype, "inspectionHandler", {
        /**
         * Get the inspection handler used by the console.
         */
        get: function () {
            return this._inspectionHandler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConsoleContent.prototype, "prompt", {
        /*
         * The console input prompt.
         */
        get: function () {
            var inputLayout = this._input.layout;
            return inputLayout.widgets.at(0) || null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConsoleContent.prototype, "session", {
        /**
         * Get the session used by the console.
         */
        get: function () {
            return this._session;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add a new cell to the content panel.
     *
     * @param cell - The cell widget being added to the content panel.
     *
     * #### Notes
     * This method is meant for use by outside classes that want to inject content
     * into a console. It is distinct from the `inject` method in that it requires
     * rendered code cell widgets and does not execute them.
     */
    ConsoleContent.prototype.addCell = function (cell) {
        this._content.addWidget(cell);
        this._cells.pushBack(cell);
        cell.disposed.connect(this._onCellDisposed, this);
        this.update();
    };
    /**
     * Clear the code cells.
     */
    ConsoleContent.prototype.clear = function () {
        // Dispose all the content cells except the first, which is the banner.
        var cells = this._content.widgets;
        while (cells.length > 1) {
            cells.at(1).dispose();
        }
    };
    /**
     * Dispose of the resources held by the widget.
     */
    ConsoleContent.prototype.dispose = function () {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        _super.prototype.dispose.call(this);
        this._completerHandler.dispose();
        this._completerHandler = null;
        this._completer.dispose();
        this._completer = null;
        this._foreignHandler.dispose();
        this._foreignHandler = null;
        this._history.dispose();
        this._history = null;
        this._inspectionHandler.dispose();
        this._inspectionHandler = null;
        this._session = null;
        this._cells.clear();
        this._cells = null;
    };
    /**
     * Execute the current prompt.
     *
     * @param force - Whether to force execution without checking code
     * completeness.
     *
     * @param timeout - The length of time, in milliseconds, that the execution
     * should wait for the API to determine whether code being submitted is
     * incomplete before attempting submission anyway. The default value is `250`.
     */
    ConsoleContent.prototype.execute = function (force, timeout) {
        var _this = this;
        if (force === void 0) { force = false; }
        if (timeout === void 0) { timeout = EXECUTION_TIMEOUT; }
        this._completer.reset();
        if (this._session.status === 'dead') {
            return Promise.resolve(void 0);
        }
        var prompt = this.prompt;
        prompt.trusted = true;
        if (force) {
            // Create a new prompt before kernel execution to allow typeahead.
            this.newPrompt();
            return this._execute(prompt);
        }
        // Check whether we should execute.
        return this._shouldExecute(timeout).then(function (should) {
            if (should) {
                // Create a new prompt before kernel execution to allow typeahead.
                _this.newPrompt();
                return _this._execute(prompt);
            }
        });
    };
    /**
     * Inject arbitrary code for the console to execute immediately.
     *
     * @param code - The code contents of the cell being injected.
     *
     * @returns A promise that indicates when the injected cell's execution ends.
     */
    ConsoleContent.prototype.inject = function (code) {
        // Create a new cell using the prompt renderer.
        var cell = this._renderer.createPrompt(this._rendermime, this);
        cell.model.source = code;
        cell.mimetype = this._mimetype;
        cell.readOnly = true;
        this.addCell(cell);
        return this._execute(cell);
    };
    /**
     * Insert a line break in the prompt.
     */
    ConsoleContent.prototype.insertLinebreak = function () {
        var prompt = this.prompt;
        var model = prompt.model;
        model.source += '\n';
        prompt.editor.setCursorPosition(model.source.length);
    };
    /**
     * Serialize the output.
     */
    ConsoleContent.prototype.serialize = function () {
        var prompt = this.prompt;
        var layout = this._content.layout;
        // Serialize content.
        var output = iteration_1.map(layout.widgets, function (widget) {
            return widget.model.toJSON();
        });
        // Serialize prompt and return.
        return iteration_1.toArray(output).concat(prompt.model.toJSON());
    };
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the notebook panel's node. It should
     * not be called directly by user code.
     */
    ConsoleContent.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'keydown':
                this._evtKeyDown(event);
                break;
            default:
                break;
        }
    };
    /**
     * Handle `after_attach` messages for the widget.
     */
    ConsoleContent.prototype.onAfterAttach = function (msg) {
        var node = this.node;
        node.addEventListener('keydown', this, true);
        // Create a prompt if necessary.
        if (!this.prompt) {
            this.newPrompt();
        }
        // Listen for kernel change events.
        this._addSessionListeners();
    };
    /**
     * Handle `before_detach` messages for the widget.
     */
    ConsoleContent.prototype.onBeforeDetach = function (msg) {
        var node = this.node;
        node.removeEventListener('keydown', this, true);
    };
    /**
     * Handle `'activate-request'` messages.
     */
    ConsoleContent.prototype.onActivateRequest = function (msg) {
        messaging_1.sendMessage(this.prompt.editor, widget_1.WidgetMessage.ActivateRequest);
        this.update();
    };
    /**
     * Make a new prompt.
     */
    ConsoleContent.prototype.newPrompt = function () {
        var prompt = this.prompt;
        var input = this._input;
        // Make the last prompt read-only, clear its signals, and move to content.
        if (prompt) {
            prompt.readOnly = true;
            prompt.removeClass(PROMPT_CLASS);
            signaling_1.clearSignalData(prompt.editor);
            input.layout.removeWidgetAt(0);
            this.addCell(prompt);
        }
        // Create the new prompt.
        prompt = this._renderer.createPrompt(this._rendermime, this);
        prompt.mimetype = this._mimetype;
        prompt.addClass(PROMPT_CLASS);
        this._input.addWidget(prompt);
        // Hook up history handling.
        var editor = prompt.editor;
        editor.edgeRequested.connect(this.onEdgeRequest, this);
        editor.textChanged.connect(this.onTextChange, this);
        // Associate the new prompt with the completer and inspection handlers.
        this._completerHandler.activeCell = prompt;
        this._inspectionHandler.activeCell = prompt;
        messaging_1.sendMessage(prompt.editor, widget_1.WidgetMessage.ActivateRequest);
        this.update();
    };
    /**
     * Handle an edge requested signal.
     */
    ConsoleContent.prototype.onEdgeRequest = function (editor, location) {
        var _this = this;
        var prompt = this.prompt;
        if (location === 'top') {
            return this._history.back(prompt.model.source).then(function (value) {
                if (!value) {
                    return;
                }
                if (prompt.model.source === value) {
                    return;
                }
                _this._setByHistory = true;
                prompt.model.source = value;
                prompt.editor.setCursorPosition(0);
            });
        }
        return this._history.forward(prompt.model.source).then(function (value) {
            var text = value || _this._history.placeholder;
            if (prompt.model.source === text) {
                return;
            }
            _this._setByHistory = true;
            prompt.model.source = text;
            prompt.editor.setCursorPosition(text.length);
        });
    };
    /**
     * Handle a text change signal from the editor.
     */
    ConsoleContent.prototype.onTextChange = function (editor, args) {
        if (this._setByHistory) {
            this._setByHistory = false;
            return;
        }
        this._history.reset();
    };
    /**
     * Handle `update-request` messages.
     */
    ConsoleContent.prototype.onUpdateRequest = function (msg) {
        Private.scrollToBottom(this._content.node);
    };
    /**
     * Handle the `'keydown'` event for the widget.
     */
    ConsoleContent.prototype._evtKeyDown = function (event) {
        if (event.keyCode === 13 && !this.prompt.editor.hasFocus()) {
            this.prompt.editor.activate();
        }
    };
    /**
     * Handle kernel change events on the session.
     */
    ConsoleContent.prototype._addSessionListeners = function () {
        var _this = this;
        if (this._listening) {
            return;
        }
        this._listening = this._session.kernelChanged.connect(function (sender, kernel) {
            _this.clear();
            _this.newPrompt();
            _this._initialize();
            _this._history.kernel = kernel;
            _this._completerHandler.kernel = kernel;
            _this._foreignHandler.kernel = kernel;
            _this._inspectionHandler.kernel = kernel;
        });
    };
    /**
     * Initialize the banner and mimetype.
     */
    ConsoleContent.prototype._initialize = function () {
        var _this = this;
        var kernel = this._session.kernel;
        kernel.ready.then(function () {
            _this._handleInfo(kernel.info);
        });
    };
    /**
     * Execute the code in the current prompt.
     */
    ConsoleContent.prototype._execute = function (cell) {
        var _this = this;
        this._history.push(cell.model.source);
        cell.model.contentChanged.connect(this.update, this);
        var onSuccess = function (value) {
            _this.executed.emit(new Date());
            if (!value) {
                return;
            }
            if (value.content.status === 'ok') {
                var content = value.content;
                // Use deprecated payloads for backwards compatibility.
                if (content.payload && content.payload.length) {
                    var setNextInput = content.payload.filter(function (i) {
                        return i.source === 'set_next_input';
                    })[0];
                    if (setNextInput) {
                        var text = setNextInput.text;
                        // Ignore the `replace` value and always set the next cell.
                        cell.model.source = text;
                    }
                }
            }
            cell.model.contentChanged.disconnect(_this.update, _this);
            _this.update();
        };
        var onFailure = function () {
            cell.model.contentChanged.disconnect(_this.update, _this);
            _this.update();
        };
        return cell.execute(this._session.kernel).then(onSuccess, onFailure);
    };
    /**
     * Update the console based on the kernel info.
     */
    ConsoleContent.prototype._handleInfo = function (info) {
        var layout = this._content.layout;
        var banner = layout.widgets.at(0);
        banner.model.source = info.banner;
        var lang = info.language_info;
        this._mimetype = this._renderer.getCodeMimetype(lang);
        if (this.prompt) {
            this.prompt.mimetype = this._mimetype;
        }
    };
    /**
     * Create a new completer widget if necessary and initialize it.
     */
    ConsoleContent.prototype._newCompleter = function (completer) {
        // Instantiate completer widget.
        this._completer = completer || new completer_1.CompleterWidget({
            model: new completer_1.CompleterModel()
        });
        // Set the completer widget's anchor node to peg its position.
        this._completer.anchor = this.node;
        // Because a completer widget may be passed in, check if it is attached.
        if (!this._completer.isAttached) {
            widget_1.Widget.attach(this._completer, document.body);
        }
        // Set up the completer handler.
        this._completerHandler = new completer_1.CellCompleterHandler({
            completer: this._completer,
            kernel: this._session.kernel
        });
    };
    /**
     * Create a new foreign cell.
     */
    ConsoleContent.prototype._newForeignCell = function () {
        var cell = this._renderer.createForeignCell(this._rendermime, this);
        cell.readOnly = true;
        cell.mimetype = this._mimetype;
        cell.addClass(FOREIGN_CELL_CLASS);
        return cell;
    };
    /**
     * Handle cell disposed signals.
     */
    ConsoleContent.prototype._onCellDisposed = function (sender, args) {
        if (!this.isDisposed) {
            this._cells.remove(sender);
        }
    };
    /**
     * Test whether we should execute the prompt.
     */
    ConsoleContent.prototype._shouldExecute = function (timeout) {
        var _this = this;
        var prompt = this.prompt;
        var code = prompt.model.source + '\n';
        return new Promise(function (resolve, reject) {
            var timer = setTimeout(function () { resolve(true); }, timeout);
            _this._session.kernel.requestIsComplete({ code: code }).then(function (isComplete) {
                clearTimeout(timer);
                if (isComplete.content.status !== 'incomplete') {
                    resolve(true);
                    return;
                }
                prompt.model.source = code + isComplete.content.indent;
                prompt.editor.setCursorPosition(prompt.model.source.length);
                resolve(false);
            }).catch(function () { resolve(true); });
        });
    };
    return ConsoleContent;
}(widget_1.Widget));
exports.ConsoleContent = ConsoleContent;
// Define the signals for the `ConsoleContent` class.
signaling_1.defineSignal(ConsoleContent.prototype, 'executed');
/**
 * A namespace for ConsoleContent statics.
 */
var ConsoleContent;
(function (ConsoleContent) {
    /* tslint:disable */
    /**
     * The console renderer token.
     */
    ConsoleContent.IRenderer = new token_1.Token('jupyter.services.console.renderer');
})(ConsoleContent = exports.ConsoleContent || (exports.ConsoleContent = {}));
/**
 * A namespace for console widget private data.
 */
var Private;
(function (Private) {
    /**
     * Jump to the bottom of a node.
     *
     * @param node - The scrollable element.
     */
    function scrollToBottom(node) {
        node.scrollTop = node.scrollHeight - node.clientHeight;
    }
    Private.scrollToBottom = scrollToBottom;
})(Private || (Private = {}));
//# sourceMappingURL=content.js.map