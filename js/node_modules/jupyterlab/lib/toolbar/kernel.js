// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var widget_1 = require('phosphor/lib/ui/widget');
var docregistry_1 = require('../docregistry');
var index_1 = require('./index');
/**
 * The class name added to toolbar interrupt button.
 */
var TOOLBAR_INTERRUPT_CLASS = 'jp-Kernel-toolbarInterrupt';
/**
 * The class name added to toolbar restart button.
 */
var TOOLBAR_RESTART_CLASS = 'jp-Kernel-toolbarRestart';
/**
 * The class name added to toolbar kernel name text.
 */
var TOOLBAR_KERNEL_CLASS = 'jp-Kernel-toolbarKernelName';
/**
 * The class name added to toolbar kernel indicator icon.
 */
var TOOLBAR_INDICATOR_CLASS = 'jp-Kernel-toolbarKernelIndicator';
/**
 * The class name added to a busy kernel indicator.
 */
var TOOLBAR_BUSY_CLASS = 'jp-mod-busy';
/**
 * Create an interrupt toolbar item.
 */
function createInterruptButton(kernelOwner) {
    return new index_1.ToolbarButton({
        className: TOOLBAR_INTERRUPT_CLASS,
        onClick: function () {
            if (kernelOwner.kernel) {
                kernelOwner.kernel.interrupt();
            }
        },
        tooltip: 'Interrupt the kernel'
    });
}
exports.createInterruptButton = createInterruptButton;
/**
 * Create a restart toolbar item.
 */
function createRestartButton(kernelOwner, host) {
    return new index_1.ToolbarButton({
        className: TOOLBAR_RESTART_CLASS,
        onClick: function () {
            docregistry_1.restartKernel(kernelOwner.kernel, host);
        },
        tooltip: 'Restart the kernel'
    });
}
exports.createRestartButton = createRestartButton;
/**
 * Create a kernel name indicator item.
 *
 * #### Notes
 * It will display the `'display_name`' of the current kernel,
 * or `'No Kernel!'` if there is no kernel.
 * It can handle a change in context or kernel.
 */
function createKernelNameItem(kernelOwner) {
    var widget = new widget_1.Widget();
    widget.addClass(TOOLBAR_KERNEL_CLASS);
    updateKernelNameItem(widget, kernelOwner.kernel);
    kernelOwner.kernelChanged.connect(function () {
        updateKernelNameItem(widget, kernelOwner.kernel);
    });
    return widget;
}
exports.createKernelNameItem = createKernelNameItem;
/**
 * Update the text of the kernel name item.
 */
function updateKernelNameItem(widget, kernel) {
    widget.node.textContent = 'No Kernel!';
    if (!kernel) {
        return;
    }
    kernel.getSpec().then(function (spec) {
        if (!widget.isDisposed) {
            widget.node.textContent = spec.display_name;
        }
    });
}
/**
 * Create a kernel status indicator item.
 *
 * #### Notes
 * It show display a busy status if the kernel status is
 * not idle.
 * It will show the current status in the node title.
 * It can handle a change to the context or the kernel.
 */
function createKernelStatusItem(kernelOwner) {
    return new KernelIndicator(kernelOwner);
}
exports.createKernelStatusItem = createKernelStatusItem;
/**
 * A toolbar item that displays kernel status.
 */
var KernelIndicator = (function (_super) {
    __extends(KernelIndicator, _super);
    /**
     * Construct a new kernel status widget.
     */
    function KernelIndicator(kernelOwner) {
        var _this = this;
        _super.call(this);
        this.addClass(TOOLBAR_INDICATOR_CLASS);
        if (kernelOwner.kernel) {
            this._handleStatus(kernelOwner.kernel, kernelOwner.kernel.status);
            kernelOwner.kernel.statusChanged.connect(this._handleStatus, this);
        }
        else {
            this.addClass(TOOLBAR_BUSY_CLASS);
            this.node.title = 'No Kernel!';
        }
        kernelOwner.kernelChanged.connect(function (c, kernel) {
            if (kernel) {
                _this._handleStatus(kernel, kernel.status);
                kernel.statusChanged.connect(_this._handleStatus, _this);
            }
            else {
                _this.node.title = 'No Kernel!';
                _this.addClass(TOOLBAR_BUSY_CLASS);
            }
        });
    }
    /**
     * Handle a status on a kernel.
     */
    KernelIndicator.prototype._handleStatus = function (kernel, status) {
        if (this.isDisposed) {
            return;
        }
        this.toggleClass(TOOLBAR_BUSY_CLASS, status !== 'idle');
        var title = 'Kernel ' + status[0].toUpperCase() + status.slice(1);
        this.node.title = title;
    };
    return KernelIndicator;
}(widget_1.Widget));
//# sourceMappingURL=kernel.js.map