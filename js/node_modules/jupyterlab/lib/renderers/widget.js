// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ansi_up_1 = require('ansi_up');
var CodeMirror = require('codemirror');
require('codemirror/addon/runmode/runmode');
var codemirror_1 = require('../codemirror');
var widget_1 = require('../codemirror/widget');
var marked = require('marked');
var widget_2 = require('phosphor/lib/ui/widget');
var latex_1 = require('./latex');
/*
 * The class name added to common rendered HTML.
 */
exports.HTML_COMMON_CLASS = 'jp-RenderedHTMLCommon';
/*
 * The class name added to rendered HTML.
 */
var HTML_CLASS = 'jp-RenderedHTML';
/*
 * The class name added to rendered markdown.
 */
var MARKDOWN_CLASS = 'jp-RenderedMarkdown';
/*
 * The class name added to rendered Latex.
 */
var LATEX_CLASS = 'jp-RenderedLatex';
/*
 * The class name added to rendered images.
 */
var IMAGE_CLASS = 'jp-RenderedImage';
/*
 * The class name added to rendered text.
 */
var TEXT_CLASS = 'jp-RenderedText';
/*
 * The class name added to rendered javascript.
 */
var JAVASCRIPT_CLASS = 'jp-RenderedJavascript';
/*
 * The class name added to rendered SVG.
 */
var SVG_CLASS = 'jp-RenderedSVG';
/*
 * The class name added to rendered PDF.
 */
var PDF_CLASS = 'jp-RenderedPDF';
// Support GitHub flavored Markdown, leave sanitizing to external library.
marked.setOptions({
    gfm: true,
    sanitize: false,
    tables: true,
    // breaks: true; We can't use GFM breaks as it causes problems with HTML tables
    langPrefix: "cm-s-" + widget_1.DEFAULT_CODEMIRROR_THEME + " language-",
    highlight: function (code, lang, callback) {
        if (!lang) {
            // no language, no highlight
            if (callback) {
                callback(null, code);
                return;
            }
            else {
                return code;
            }
        }
        codemirror_1.requireMode(lang).then(function (spec) {
            var el = document.createElement('div');
            if (!spec) {
                console.log("No CodeMirror mode: " + lang);
                callback(null, code);
                return;
            }
            try {
                CodeMirror.runMode(code, spec.mime, el);
                callback(null, el.innerHTML);
            }
            catch (err) {
                console.log("Failed to highlight " + lang + " code", err);
                callback(err, code);
            }
        }).catch(function (err) {
            console.log("No CodeMirror mode: " + lang);
            console.log("Require CodeMirror mode error: " + err);
            callback(null, code);
        });
    }
});
/*
 * A widget for displaying any widget whoes representation is rendered HTML
 * */
var RenderedHTMLCommon = (function (_super) {
    __extends(RenderedHTMLCommon, _super);
    /* Construct a new rendered HTML common widget.*/
    function RenderedHTMLCommon(options) {
        _super.call(this);
        this.addClass(exports.HTML_COMMON_CLASS);
    }
    return RenderedHTMLCommon;
}(widget_2.Widget));
exports.RenderedHTMLCommon = RenderedHTMLCommon;
/**
 * A widget for displaying HTML and rendering math.
 */
var RenderedHTML = (function (_super) {
    __extends(RenderedHTML, _super);
    /**
     * Construct a new html widget.
     */
    function RenderedHTML(options) {
        _super.call(this, options);
        this.addClass(HTML_CLASS);
        var source = options.source;
        if (options.sanitizer) {
            source = options.sanitizer.sanitize(source);
        }
        appendHtml(this.node, source);
        if (options.resolver) {
            resolveUrls(this.node, options.resolver);
        }
    }
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    RenderedHTML.prototype.onAfterAttach = function (msg) {
        latex_1.typeset(this.node);
    };
    return RenderedHTML;
}(RenderedHTMLCommon));
exports.RenderedHTML = RenderedHTML;
/**
 * A widget for displaying Markdown with embeded latex.
 */
var RenderedMarkdown = (function (_super) {
    __extends(RenderedMarkdown, _super);
    /**
     * Construct a new markdown widget.
     */
    function RenderedMarkdown(options) {
        var _this = this;
        _super.call(this, options);
        this._rendered = false;
        this.addClass(MARKDOWN_CLASS);
        var parts = latex_1.removeMath(options.source);
        // Add the markdown content asynchronously.
        marked(parts['text'], function (err, content) {
            if (err) {
                console.error(err);
                return;
            }
            content = latex_1.replaceMath(content, parts['math']);
            if (options.sanitizer) {
                content = options.sanitizer.sanitize(content);
            }
            appendHtml(_this.node, content);
            if (options.resolver) {
                resolveUrls(_this.node, options.resolver);
            }
            _this.fit();
            _this._rendered = true;
            if (_this.isAttached) {
                latex_1.typeset(_this.node);
            }
        });
    }
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    RenderedMarkdown.prototype.onAfterAttach = function (msg) {
        if (this._rendered) {
            latex_1.typeset(this.node);
        }
    };
    return RenderedMarkdown;
}(RenderedHTMLCommon));
exports.RenderedMarkdown = RenderedMarkdown;
/**
 * A widget for displaying LaTeX output.
 */
var RenderedLatex = (function (_super) {
    __extends(RenderedLatex, _super);
    /**
     * Construct a new latex widget.
     */
    function RenderedLatex(options) {
        _super.call(this);
        this.node.textContent = options.source;
        this.addClass(LATEX_CLASS);
    }
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    RenderedLatex.prototype.onAfterAttach = function (msg) {
        latex_1.typeset(this.node);
    };
    return RenderedLatex;
}(widget_2.Widget));
exports.RenderedLatex = RenderedLatex;
var RenderedImage = (function (_super) {
    __extends(RenderedImage, _super);
    function RenderedImage(options) {
        _super.call(this);
        var img = document.createElement('img');
        img.src = "data:" + options.mimetype + ";base64," + options.source;
        this.node.appendChild(img);
        this.addClass(IMAGE_CLASS);
    }
    return RenderedImage;
}(widget_2.Widget));
exports.RenderedImage = RenderedImage;
var RenderedText = (function (_super) {
    __extends(RenderedText, _super);
    function RenderedText(options) {
        _super.call(this);
        var data = ansi_up_1.escape_for_html(options.source);
        var pre = document.createElement('pre');
        pre.innerHTML = ansi_up_1.ansi_to_html(data);
        this.node.appendChild(pre);
        this.addClass(TEXT_CLASS);
    }
    return RenderedText;
}(widget_2.Widget));
exports.RenderedText = RenderedText;
var RenderedJavascript = (function (_super) {
    __extends(RenderedJavascript, _super);
    function RenderedJavascript(options) {
        _super.call(this);
        var s = document.createElement('script');
        s.type = options.mimetype;
        s.textContent = options.source;
        this.node.appendChild(s);
        this.addClass(JAVASCRIPT_CLASS);
    }
    return RenderedJavascript;
}(widget_2.Widget));
exports.RenderedJavascript = RenderedJavascript;
var RenderedSVG = (function (_super) {
    __extends(RenderedSVG, _super);
    function RenderedSVG(options) {
        _super.call(this);
        this.node.innerHTML = options.source;
        var svgElement = this.node.getElementsByTagName('svg')[0];
        if (!svgElement) {
            throw new Error('SVGRender: Error: Failed to create <svg> element');
        }
        if (options.resolver) {
            resolveUrls(this.node, options.resolver);
        }
        this.addClass(SVG_CLASS);
    }
    return RenderedSVG;
}(widget_2.Widget));
exports.RenderedSVG = RenderedSVG;
var RenderedPDF = (function (_super) {
    __extends(RenderedPDF, _super);
    function RenderedPDF(options) {
        _super.call(this);
        var a = document.createElement('a');
        a.target = '_blank';
        a.textContent = 'View PDF';
        a.href = 'data:application/pdf;base64,' + options.source;
        this.node.appendChild(a);
        this.addClass(PDF_CLASS);
    }
    return RenderedPDF;
}(widget_2.Widget));
exports.RenderedPDF = RenderedPDF;
/**
 * Resolve the relative urls in the image and anchor tags of a node tree.
 *
 * @param node - The head html element.
 *
 * @param resolver - A url resolver.
 */
function resolveUrls(node, resolver) {
    var imgs = node.getElementsByTagName('img');
    for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        var source = img.getAttribute('src');
        if (source) {
            img.src = resolver.resolveUrl(source);
        }
    }
    var anchors = node.getElementsByTagName('a');
    for (var i = 0; i < anchors.length; i++) {
        var anchor = anchors[i];
        var href = anchor.getAttribute('href');
        if (href) {
            anchor.href = resolver.resolveUrl(href);
        }
    }
}
exports.resolveUrls = resolveUrls;
/**
 * Append trusted html to a node.
 */
function appendHtml(node, html) {
    try {
        var range = document.createRange();
        node.appendChild(range.createContextualFragment(html));
    }
    catch (error) {
        console.warn('Environment does not support Range ' +
            'createContextualFragment, falling back on innerHTML');
        node.innerHTML = html;
    }
}
//# sourceMappingURL=widget.js.map