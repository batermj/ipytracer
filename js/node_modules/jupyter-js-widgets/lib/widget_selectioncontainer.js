// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var widget_1 = require("./widget");
var widget_box_1 = require("./widget_box");
var tabbar_1 = require("phosphor/lib/ui/tabbar");
var panel_1 = require("phosphor/lib/ui/panel");
var title_1 = require("phosphor/lib/ui/title");
var iteration_1 = require("phosphor/lib/algorithm/iteration");
var searching_1 = require("phosphor/lib/algorithm/searching");
var _ = require("underscore");
var utils = require("./utils");
var $ = require("jquery");
var SelectionContainerModel = (function (_super) {
    __extends(SelectionContainerModel, _super);
    function SelectionContainerModel() {
        return _super.apply(this, arguments) || this;
    }
    SelectionContainerModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _model_name: 'SelectionContainerModel',
            selected_index: 0,
            _titles: {}
        });
    };
    return SelectionContainerModel;
}(widget_box_1.BoxModel));
exports.SelectionContainerModel = SelectionContainerModel;
var AccordionModel = (function (_super) {
    __extends(AccordionModel, _super);
    function AccordionModel() {
        return _super.apply(this, arguments) || this;
    }
    AccordionModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _model_name: 'AccordionModel',
            _view_name: 'AccordionView'
        });
    };
    return AccordionModel;
}(SelectionContainerModel));
exports.AccordionModel = AccordionModel;
var AccordionView = (function (_super) {
    __extends(AccordionView, _super);
    function AccordionView() {
        var _this = _super.apply(this, arguments) || this;
        _this.pages = [];
        _this.view_pages = Object.create(null);
        return _this;
    }
    AccordionView.prototype.initialize = function (parameters) {
        var _this = this;
        _super.prototype.initialize.call(this, parameters);
        this.children_views = new widget_1.ViewList(this.add_child_view, this.remove_child_view, this);
        this.listenTo(this.model, 'change:children', function (model, value, options) {
            _this.children_views.update(value);
        });
    };
    /**
     * Called when view is rendered.
     */
    AccordionView.prototype.render = function () {
        this.el.className = 'jupyter-widgets widget-container widget-accordion';
        this.listenTo(this.model, 'change:selected_index', function (model, value, options) {
            this.update_selected_index(options);
        });
        this.listenTo(this.model, 'change:_titles', function (model, value, options) {
            this.update_titles(options);
        });
        this.children_views.update(this.model.get('children'));
        this.update_titles();
        this.update_selected_index();
    };
    /**
     * Set header titles
     */
    AccordionView.prototype.update_titles = function () {
        var titles = this.model.get('_titles');
        for (var i = 0; i < this.pages.length; i++) {
            if (titles[i] !== void 0) {
                this.pages[i].firstChild.textContent = titles[i];
            }
        }
    };
    /**
     * Make the rendering and selected index consistent.
     */
    AccordionView.prototype.update_selected_index = function (options) {
        var new_index = this.model.get('selected_index');
        this.pages.forEach(function (page, index) {
            if (index === new_index) {
                page.classList.add('accordion-active');
                // TODO: use CSS transitions?
                $(page.lastElementChild).slideDown('fast');
            }
            else {
                page.classList.remove('accordion-active');
                $(page.lastElementChild).slideUp('fast');
            }
        });
    };
    /**
     * Called when a child is removed from children list.
     */
    AccordionView.prototype.remove_child_view = function (view) {
        var page = this.view_pages[view.cid];
        this.pages.splice(this.pages.indexOf(page), 1);
        delete this.view_pages[view.cid];
        page.parentNode.removeChild(page);
        view.remove();
    };
    /**
     * Called when a child is added to children list.
     */
    AccordionView.prototype.add_child_view = function (model) {
        var _this = this;
        var page = document.createElement('div');
        page.classList.add('accordion-page');
        var header = document.createElement('div');
        header.classList.add('accordion-header');
        header.textContent = "Page " + this.pages.length;
        header.onclick = function () {
            var index = _this.pages.indexOf(page);
            _this.model.set('selected_index', index);
            _this.touch();
        };
        var content = document.createElement('div');
        content.classList.add('accordion-content');
        page.appendChild(header);
        page.appendChild(content);
        this.pages.push(page);
        this.el.appendChild(page);
        this.update_titles();
        this.update_selected_index;
        return this.create_child_view(model).then(function (view) {
            _this.view_pages[view.cid] = page;
            content.appendChild(view.el);
            // Trigger the displayed event of the child view.
            _this.displayed.then(function () {
                view.trigger('displayed', _this);
            });
            return view;
        }).catch(utils.reject('Could not add child view to box', true));
    };
    /**
     * We remove this widget before removing the children as an optimization
     * we want to remove the entire container from the DOM first before
     * removing each individual child separately.
     */
    AccordionView.prototype.remove = function () {
        _super.prototype.remove.call(this);
        this.children_views.remove();
    };
    return AccordionView;
}(widget_1.DOMWidgetView));
exports.AccordionView = AccordionView;
var TabModel = (function (_super) {
    __extends(TabModel, _super);
    function TabModel() {
        return _super.apply(this, arguments) || this;
    }
    TabModel.prototype.defaults = function () {
        return _.extend(_super.prototype.defaults.call(this), {
            _model_name: 'TabModel',
            _view_name: 'TabView'
        });
    };
    return TabModel;
}(SelectionContainerModel));
exports.TabModel = TabModel;
// We implement our own tab widget since Phoshpor's TabPanel uses an absolute
// positioning BoxLayout, but we want a more an html/css-based Panel layout.
var TabView = (function (_super) {
    __extends(TabView, _super);
    function TabView() {
        var _this = _super.apply(this, arguments) || this;
        _this.updatingTabs = false;
        return _this;
    }
    TabView.prototype._createElement = function (tagName) {
        this.pWidget = new widget_box_1.JupyterPhosphorPanelWidget({ view: this });
        return this.pWidget.node;
    };
    TabView.prototype._setElement = function (el) {
        if (this.el || el !== this.pWidget.node) {
            // TabViews don't allow setting the element beyond the initial creation.
            throw new Error('Cannot reset the DOM element.');
        }
        this.el = this.pWidget.node;
        this.$el = $(this.pWidget.node);
    };
    /**
     * Public constructor.
     */
    TabView.prototype.initialize = function (parameters) {
        var _this = this;
        _super.prototype.initialize.call(this, parameters);
        this.childrenViews = new widget_1.ViewList(this.addChildView, function (view) { view.remove(); }, this);
        this.listenTo(this.model, 'change:children', function () { return _this.updateTabs(); });
        this.listenTo(this.model, 'change:_titles', function () { return _this.updateTitles(); });
    };
    /**
     * Called when view is rendered.
     */
    TabView.prototype.render = function () {
        this.pWidget.addClass('jupyter-widgets');
        this.pWidget.addClass('widget-container');
        this.pWidget.addClass('widget-tab');
        this.tabBar = new tabbar_1.TabBar({ insertBehavior: 'none' });
        this.tabBar.tabsMovable = false;
        this.tabBar.addClass('widget-tab-bar');
        this.tabBar.currentChanged.connect(this._onTabChanged, this);
        this.tabContents = new panel_1.Panel();
        this.tabContents.addClass('widget-tab-contents');
        this.pWidget.addWidget(this.tabBar);
        this.pWidget.addWidget(this.tabContents);
        this.updateTabs();
        this.update();
    };
    /**
     * Render tab views based on the current model's children.
     */
    TabView.prototype.updateTabs = function () {
        // While we are updating, the index may not be valid, so deselect the
        // tabs before updating so we don't get spurious changes in the index.
        this.updatingTabs = true;
        var oldTitle = this.tabBar.currentTitle;
        this.tabBar.currentIndex = -1;
        this.childrenViews.update(this.model.get('children'));
        this.tabBar.currentIndex = this.model.get('selected_index');
        var newTitle = this.tabBar.currentTitle;
        if (oldTitle !== newTitle) {
            if (oldTitle && oldTitle.owner) {
                oldTitle.owner.hide();
            }
            if (newTitle && newTitle.owner) {
                newTitle.owner.show();
            }
        }
        this.updatingTabs = false;
    };
    /**
     * Called when a child is added to children list.
     */
    TabView.prototype.addChildView = function (model, index) {
        var _this = this;
        // Placeholder title to keep our position in the tab bar while we create the view.
        var label = this.model.get('_titles')[index] || (index + 1).toString();
        var tempTitle = new title_1.Title({ label: label });
        this.tabBar.addTab(tempTitle);
        return this.create_child_view(model).then(function (view) {
            var widget = view.pWidget;
            widget.hide();
            widget.addClass('widget-tab-child');
            _this.tabContents.addWidget(widget);
            var title = widget.title;
            title.closable = false;
            title.label = tempTitle.label;
            var i = searching_1.indexOf(_this.tabBar.titles, tempTitle);
            // insert after tempTitle so that if tempTitle is selected,
            // after this the replacement title will be selected.
            _this.tabBar.insertTab(i + 1, title);
            _this.tabBar.removeTab(tempTitle);
            view.on('remove', function () { return _this.tabBar.removeTab(title); });
            if (_this.tabBar.currentTitle === title) {
                widget.show();
            }
            return view;
        }).catch(utils.reject('Could not add child view to box', true));
    };
    /**
     * Update the contents of this view
     *
     * Called when the model is changed.  The model may have been
     * changed by another view or by a state update from the back-end.
     */
    TabView.prototype.update = function () {
        // Update the selected index in the overall update method because it
        // should be run after the tabs have been updated. Otherwise the
        // selected index may not be a valid tab in the tab bar.
        this.updateSelectedIndex();
        return _super.prototype.update.call(this);
    };
    /**
     * Updates the tab page titles.
     */
    TabView.prototype.updateTitles = function () {
        var titles = this.model.get('_titles') || {};
        iteration_1.each(iteration_1.enumerate(this.tabBar.titles), function (_a) {
            var i = _a[0], title = _a[1];
            title.label = titles[i] || (i + 1).toString();
        });
    };
    /**
     * Updates the selected index.
     */
    TabView.prototype.updateSelectedIndex = function () {
        var current = this.model.get('selected_index');
        var previous = this.model.previous('selected_index');
        if (current === void 0) {
            current = 0;
        }
        var titles = this.tabBar.titles;
        if (0 <= current && current < titles.length) {
            if (previous !== void 0 && previous !== current) {
                var previousTitle = titles.at(previous);
                var previousWidget = previousTitle ? previousTitle.owner : null;
                if (previousWidget) {
                    previousWidget.hide();
                }
            }
            this.tabBar.currentIndex = current;
            var currentWidget = this.tabBar.currentTitle.owner;
            if (currentWidget) {
                currentWidget.show();
            }
        }
    };
    TabView.prototype.remove = function () {
        this.tabBar = null;
        this.tabContents = null;
        // Remove this widget before children so that the entire container
        // leaves the DOM at once.
        _super.prototype.remove.call(this);
        this.childrenViews.remove();
    };
    TabView.prototype._onTabChanged = function (sender, args) {
        if (!this.updatingTabs) {
            this.model.set('selected_index', args.currentIndex);
            this.touch();
        }
    };
    return TabView;
}(widget_1.DOMWidgetView));
exports.TabView = TabView;
